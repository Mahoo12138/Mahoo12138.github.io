<!DOCTYPE html>
<html lang="en" color-mode="light">

  <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="keywords" content="" />
  <meta name="author" content="Mahoo12138" />
  <meta name="description" content="" />
  
  
  <title>
    
      那个初夏的夜晚——与ADC的浪漫邂逅 
      
      
      |
    
     Mahoo12138
  </title>

  
    <link rel="apple-touch-icon" href="/images/favicon.png">
    <link rel="icon" href="/images/favicon.png">
  

  <!-- Raleway-Font -->
  <link href="https://fonts.googleapis.com/css?family=Raleway&display=swap" rel="stylesheet">

  <!-- hexo site css -->
  <link rel="stylesheet" href="/css/main.css" />
  <link rel="stylesheet" href="//at.alicdn.com/t/font_1886449_67xjft27j1l.css" />
  <!-- 代码块风格 -->
  

  <!-- jquery3.3.1 -->
  
    <script defer type="text/javascript" src="/plugins/jquery.min.js"></script>
  

  <!-- fancybox -->
  
    <link href="/plugins/jquery.fancybox.min.css" rel="stylesheet">
    <script defer type="text/javascript" src="/plugins/jquery.fancybox.min.js"></script>
  
  
<script src="/js/fancybox.js"></script>


  

  

  <script>
    var html = document.documentElement
    const colorMode = localStorage.getItem('color-mode')
    if (colorMode) {
      document.documentElement.setAttribute('color-mode', colorMode)
    }
  </script>
<meta name="generator" content="Hexo 7.2.0"></head>


  <body>
    <div id="app">
      <div class="header">
  <div class="avatar">
    <a href="/">
      <!-- 头像取消懒加载，添加no-lazy -->
      
        <img src="/images/avatar.png" alt="">
      
    </a>
    <div class="nickname"><a href="/">Mahoo12138</a></div>
  </div>
  <div class="navbar">
    <ul>
      
        <li class="nav-item" data-path="/">
          <a href="/">Home</a>
        </li>
      
        <li class="nav-item" data-path="/archives/">
          <a href="/archives/">Archives</a>
        </li>
      
        <li class="nav-item" data-path="/tags/">
          <a href="/tags/">Tags</a>
        </li>
      
        <li class="nav-item" data-path="/friends/">
          <a href="/friends/">Friends</a>
        </li>
      
        <li class="nav-item" data-path="/about/">
          <a href="/about/">About</a>
        </li>
      
    </ul>
  </div>
</div>


<script src="/js/activeNav.js"></script>



      <div class="flex-container">
        <!-- 文章详情页，展示文章具体内容，url形式：https://yoursite/文章标题/ -->
<!-- 同时为「标签tag」，「朋友friend」，「分类categories」，「关于about」页面的承载页面，具体展示取决于page.type -->


  <!-- LaTex Display -->

  
    <script async type="text/javascript" src="/plugins/mathjax/tex-chtml.js"></script>
  
  <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']]
      }
    }
  </script>





  <!-- clipboard -->

  
    <script async type="text/javascript" src="/plugins/clipboard.min.js"></script>
  
  
<script src="/js/codeCopy.js"></script>







  

  

  

  
  <!-- 文章内容页 url形式：https://yoursite/文章标题/ -->
  <div class="container post-details" id="post-details">
    <div class="post-content">
      <div class="post-title">那个初夏的夜晚——与ADC的浪漫邂逅</div>
      <div class="post-attach">
        <span class="post-pubtime">
          <i class="iconfont icon-updatetime mr-10" title="Update time"></i>
          2019-06-17 23:12:43
        </span>
        
              <span class="post-tags">
                <i class="iconfont icon-tags mr-10" title="Tags"></i>
                
                <span class="span--tag mr-8">
                  <a href="/tags/STM32/" title="STM32">
                    #STM32
                  </a>
                </span>
                
              </span>
          
      </div>
      <div class="markdown-body">
        <p>注：本文属博主学习时所作笔记，内容源大参考于野火的《零死角玩转STM32F103》以及部分网络资料，笔记内容仅作为自己参考，免去频繁查询参考手册的麻烦，如有错误，还请指出！</p>
<h2 id="ADC简介"><a href="#ADC简介" class="headerlink" title="ADC简介"></a>ADC简介</h2><p>STM32f103 系列有 3 个 ADC，精度为 12 位，每个 ADC 最多有 16 个外部通道，可测量16个外部和2个内部信号源。其中ADC1 和 ADC2 都有 16 个外部通道，ADC3 根据 CPU 引脚的不同通道数也不同，一般都有8 个外部通道。</p>
<p>ADC的结果可以左对齐或右对齐方式存储在16位数据寄存器中。</p>
<p><img src="https://cdn.jsdelivr.net/gh/mahoo12138/js-css-cdn/hexo-images/study/STM32/adc.png" alt="单个ADC框图"></p>
<h3 id="电压输入范围"><a href="#电压输入范围" class="headerlink" title="电压输入范围"></a>电压输入范围</h3><p>输入电压：$V_{REF-} \leq V_{IN} \leq V_{REF+}$，决定输入电压的引脚：$V_{REF-}, V_{REF+},VDDA,VSSA$，把$VSSA$和$V_{REF-}$接地，$V_{REF+}$和$VDDA$接$3.3V$，得到ADC的输入电压范围为：&#x3D;&#x3D;0~3.3V&#x3D;&#x3D;。</p>
<blockquote>
<p> VDD： D即device 表示器件的意思，是器件内部的工作电压。 </p>
<p> VDDA(A表示 Analog 【模拟】)是模拟电源，当使用到模拟信号的时候，比如AD（模数）或者DA（数模）的时候，系统会使用VDDA的电压作为参考电压来。不要求精准使用的话，可以直接把VDDA和VDD同时接入$3.3V$就行。如果要求精准，则需要做一个稳压电路，再接入VDDA 。</p>
<p> VSS：S即series 表示公共连接的意思，通常指电路公共接地端电压 ，VSSA同理为模拟部分的电源。</p>
<p>对于数字电路来说，VCC是电路的供电电压,VDD是芯片的工作电压(通常$VCC&gt;VDD$)，$VSS$是接地点。<br>例如，对于ARM单片机来说，其供电电压$VCC$一般为5V，一般经过稳压模块将其转换为单片机工作电压$VDD &#x3D; 3.3V$。</p>
</blockquote>
<h4 id="定制电压范围"><a href="#定制电压范围" class="headerlink" title="定制电压范围"></a>定制电压范围</h4><p>例如将电压范围设成$-10V$~ $10V$，可以通过下图的附加扩展电路实现：</p>
<p><img src="https://cdn.jsdelivr.net/gh/mahoo12138/js-css-cdn/hexo-images/study/STM32/-10~10.png" alt="附加电路"></p>
<p>根据基尔霍夫定律（KCL），即节点流入的电流等于流出的电流可以得到：<br>$$<br>{(V_{IN}-V_{OUT})\over 2 } + {(3.3V-V_{OUT})\over R_1 } &#x3D; {V_{OUT} \over R_3}<br>$$<br>解得：																																		 	$V_{OUT}&#x3D;{(V_{IN}+ 10)\over 6}$</p>
<p>在附加电路的条件下，当$V_{IN}&#x3D;-10V$时，$V_{OUT}&#x3D;0$；当$V_{IN}&#x3D;10V$时，$V_{OUT}&#x3D;3.3V$。以此达到测量$-10V$~ $10V$电压的目的。</p>
<h3 id="输入通道"><a href="#输入通道" class="headerlink" title="输入通道"></a>输入通道</h3><p>输入通道，顾名思义为将电压输入到ADC的通道，STM32 的 ADC 多达 18 个通道，具体参考下图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/mahoo12138/js-css-cdn/hexo-images/study/STM32/%E8%BE%93%E5%85%A5%E9%80%9A%E9%81%93.png" alt="输入通道"></p>
<p>外部的 16 个通道在转换的时候又分为规则通道和注入通道，其中规则通道最多有 16路，注入通道最多有 4 路。</p>
<ul>
<li>规则通道：也就是一般情况下用到的通道；</li>
<li>注入通道：可以在规则通道转换的时候强行插入转换，享有转换特权，有点像中断的操作。</li>
</ul>
<h3 id="转换顺序"><a href="#转换顺序" class="headerlink" title="转换顺序"></a>转换顺序</h3><ul>
<li><p>规则序列</p>
<p>转换的优先级并不是根据通道的编号来确定的，需要操作规则序列寄存器<code>SQRx</code>(x&#x3D;1,2,3)，例如将通道六设置为第十个转换，SQ10这个位写6即可。SQL1中SQL位用于设置转换通道的数量，具体的操作都可以库函数代劳。</p>
<p><img src="https://cdn.jsdelivr.net/gh/mahoo12138/js-css-cdn/hexo-images/study/STM32/%E8%BD%AC%E6%8D%A2%E9%A1%BA%E5%BA%8F_%E8%A7%84%E5%88%99.png" alt="规则序列"></p>
</li>
<li><p>注入序列</p>
<p><img src="https://cdn.jsdelivr.net/gh/mahoo12138/js-css-cdn/hexo-images/study/STM32/%E8%BD%AC%E6%8D%A2%E9%A1%BA%E5%BA%8F_%E6%B3%A8%E5%85%A5.png" alt="注入序列"></p>
<p>注入序列的转换顺序稍有不一样，当<code>JL</code>的值小于<code>4</code>时，第一次转的顺序是<code>JSQx</code>(x&#x3D;4-JL)；当JL等于4时，与SQR一致。</p>
</li>
</ul>
<h3 id="触发源"><a href="#触发源" class="headerlink" title="触发源"></a>触发源</h3><p>触发源可以看作是系统给ADC这个外设的一个信号，当触发源激活时，ADC就开始进行转换。触发源一般有两种：软件触发和外部事件触发（包括内部定时器和外部IO）；</p>
<ul>
<li><p>软件触发</p>
<p>在<code>ADC_CR2</code>的<code>ADON</code>位写1，开始转换；</p>
</li>
<li><p>外部事件触发</p>
<p>外部触发源很多，不在此详叙，主要经过<code>EXTSEL[2:0]</code>和 <code>JEXTSEL[2:0]</code>位来选择，<code>EXTTRIG</code> 和<code>JEXTTRIG</code>这两位来激活。</p>
</li>
</ul>
<h3 id="转换时间"><a href="#转换时间" class="headerlink" title="转换时间"></a>转换时间</h3><h4 id="ADC时钟"><a href="#ADC时钟" class="headerlink" title="ADC时钟"></a>ADC时钟</h4><p>ADC 输入时钟 ADC_CLK 由 PCLK2 经过分频产生，最大是 14M，分频因子由 RCC 时钟配置寄存器<code> RCC_CFGR</code> 的位 15:14 <code>ADCPRE[1:0]</code>设置，可以是 2&#x2F;4&#x2F;6&#x2F;8 分频，注意这里没有 1 分频。一般我们设置 $PCLK2&#x3D;HCLK&#x3D;72M$。</p>
<h4 id="采样时间"><a href="#采样时间" class="headerlink" title="采样时间"></a>采样时间</h4><p>ADC 使用若干个 <code>ADC_CLK</code> 周期对输入的电压进行采样，采样的周期数可通过 ADC 采样时间寄存器 <code>ADC_SMPR1</code> 和 <code>ADC_SMPR2</code> 中的 <code>SMP[2:0]</code>位设置，ADC_SMPR2 控制的是通道 0<del>9，<code>ADC_SMPR1 </code>控制的是通道 10</del>17。每个通道可以分别用不同的时间采样。其中采样周期最小是 1.5 个，即如果我们要达到最快的采样，那么应该设置采样周期为 1.5个周期，这里说的周期就是$ 1\over ADC_{CLK}$。</p>
<p>ADC 的转换时间跟 ADC 的输入时钟和采样时间有关，公式为：<br>$$<br>Tconv &#x3D; 采样时间 + 12.5 个周期。<br>$$<br>当 $ADCLK &#x3D; 14MHZ$ （最高），采样时间设置为 1.5 周期（最快），那么总的转换时间（最短）$T_{conv}$ &#x3D; 1.5 周期 + 12.5 周期 &#x3D; 14 周期 &#x3D; 1us。一般我们设置 $PCLK2&#x3D;72M$，经过 ADC 预分频器能分频到最大的时钟只能是 12M，采样周期设置为 1.5 个周期，算出最短的转换时间为 1.17us，这个才是最常用的。</p>
<h3 id="数据寄存器"><a href="#数据寄存器" class="headerlink" title="数据寄存器"></a>数据寄存器</h3><p>ADC转换后，规则组数据存放在<code>ADC_DR</code>寄存器中，注入组在<code>JDRx</code>。</p>
<h4 id="规则数据寄存器"><a href="#规则数据寄存器" class="headerlink" title="规则数据寄存器"></a>规则数据寄存器</h4><p>ADC 规则组数据寄存器 <code>ADC_DR</code> 只有一个，是一个 32 位的寄存器，低 16 位在单 ADC时使用，高 16 位是在 ADC1 中双模式下保存 ADC2 转换的规则数据，双模式就是 ADC1 和ADC2 同时使用。在单模式下，ADC1&#x2F;2&#x2F;3 都不使用高 16 位。因为 ADC 的精度是 12 位，<br>无论<code> ADC_DR</code> 的高 16 或者低 16 位都放不满，只能左对齐或者右对齐，具体是以哪一种方式存放，由 <code>ADC_CR2</code> 的 11 位 <code>ALIGN </code>设置。</p>
<p>由于数据寄存器只有一个，而通道却有多个，<strong>多通道转换时为了避免数据被覆盖，转换完成时应立刻将数据取走</strong>，一般开启<code>DMA</code>传输模式，直接将数据传输给变量。</p>
<h4 id="注入数据寄存器"><a href="#注入数据寄存器" class="headerlink" title="注入数据寄存器"></a>注入数据寄存器</h4><p>ADC 注入组最多有 4 个通道，刚好注入数据寄存器也有 4 个，每个通道对应着自己的寄存器，不会跟规则寄存器那样产生数据覆盖的问题。<code>ADC_JDRx</code> 是 32 位的，低 16 位有效，高 16 位保留，数据同样分为左对齐和右对齐，具体是以哪一种方式存放，由<br><code>ADC_CR2</code> 的 11 位<code> ALIGN</code> 设置。</p>
<h3 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h3><h4 id="转换结束中断"><a href="#转换结束中断" class="headerlink" title="转换结束中断"></a>转换结束中断</h4><p>数据转换结束后，可以产生中断，中断分为三种：</p>
<ul>
<li><p><em>规则通道转换结束中断，</em>对应中断位：<code>ADC_IT_EOC</code>;</p>
</li>
<li><p><em>注入转换通道转换结束中断，</em>对应中断位：<code>ADC_IT_JEOC</code>;</p>
</li>
<li><p><em>模拟看门狗中断</em>，对应中断位：<code>ADC_IT_AWD</code>。</p>
</li>
</ul>
<h4 id="模拟看门狗中断"><a href="#模拟看门狗中断" class="headerlink" title="模拟看门狗中断"></a>模拟看门狗中断</h4><p>当被 ADC 转换的模拟电压低于低阈值或者高于高阈值时，就会产生中断，<strong>前提是我们开启了模拟看门狗中断</strong>，其中低阈值和高阈值由 <code>ADC_LTR</code> 和 <code>ADC_HTR</code> 设置。例如我们设置的电压高阈值为3.3V，若接入的模拟电压高于3.3V时，即产生中断。</p>
<h4 id="DMA-请求"><a href="#DMA-请求" class="headerlink" title="DMA 请求"></a>DMA 请求</h4><p>规则和注入通道转换结束后，除了产生中断外，还可以产生 DMA 请求，把转换好的数据直接存储在内存里面。要注意的是<strong>只有 ADC1 和 ADC3 可以产生 DMA 请求</strong>。</p>
<h3 id="双-ADC-模式"><a href="#双-ADC-模式" class="headerlink" title="双 ADC 模式"></a>双 ADC 模式</h3><p>AD 转换包括采样阶段和转换阶段，在采样阶段才对通道数据进行采集；而在转换阶段只是将采集到的数据进行转换为数字量输出，此刻通道数据变化不会改变转换结果。独立模式的 ADC 采集需要在一个通道采集并且转换完成后才会进行下一个通道的采集。而双重 ADC 的机制就是使用两个 ADC 同时采样一个或者多个通道。双重 ADC 模式较独立模式一个最大的优势就是提高了采样率，弥补了单个 ADC 采样不够快的缺点。</p>
<p>启用双 ADC 模式的时候，通过配置 <code>ADC_CR1 </code>寄存器的<code> DUALMOD[3:0]</code>位，可以有几种不同的模式：</p>
<table>
<thead>
<tr>
<th align="center">模式</th>
<th align="left">简介</th>
</tr>
</thead>
<tbody><tr>
<td align="center">同步注入模式</td>
<td align="left">ADC1 和 ADC2 同时转换一个注入通道组，其中 ADC1 为主，ADC2 为从。转换的数据存储在每个 ADC 接口的<code>ADC_JDRx</code>寄存器中。</td>
</tr>
<tr>
<td align="center">同步规则模式</td>
<td align="left">ADC1 和 ADC2 同时转换一个规则通道组，其中 ADC1 为主，ADC2 为从。ADC1 转换的结果放在 <code>ADC1_DR</code> 的低 16 位，ADC2 转换的结果放在 <code>ADC1_DR</code> 的高十六位。</td>
</tr>
<tr>
<td align="center">快速交叉模式</td>
<td align="left">ADC1 和 ADC2 交替采集一个规则通道组（通常为一个通道）。当ADC2 触发之后，ADC1 需要等待 &#x3D;&#x3D;7&#x3D;&#x3D;个<code> ADCCLK</code> 之后才能触发。</td>
</tr>
<tr>
<td align="center">慢速交叉模式</td>
<td align="left">ADC1 和 ADC2 交替采集一个规则通道组（只能为一个通道）。当ADC2 触发之后，ADC1 需要等待 &#x3D;&#x3D;14&#x3D;&#x3D; 个<code> ADCCLK</code> 之后才能触发。</td>
</tr>
<tr>
<td align="center">交替触发模式</td>
<td align="left">ADC1 和 ADC2 轮流采集注入通道组，当 ADC1 所有通道采集完毕之后再采集 ADC2 的通道，如此循环。跟交叉采集不一样。</td>
</tr>
<tr>
<td align="center">混合的规则&#x2F;注入同步模式</td>
<td align="left">规则组同步转换被中断，以启动注入组的同步转换。分开两个模式来理解就可以了，区别就是注入组可以中断规则组的转换。</td>
</tr>
<tr>
<td align="center">混 合 的 同 步 规则+交替触发模式</td>
<td align="left">规则组同步转换被中断，以启动注入组交替触发转换。分开两个模式来理解就可以了，区别就是注入组可以中断规则组的转换。</td>
</tr>
<tr>
<td align="center">混合同步注入+交叉模式</td>
<td align="left">交叉转换可以被同步注入模式中断。这种情况下，交叉转换被中断，注入转换被启动。</td>
</tr>
</tbody></table>
<h2 id="例程设计"><a href="#例程设计" class="headerlink" title="例程设计"></a>例程设计</h2><p>STM32 的 ADC 功能繁多，以下通过三个基础例程尽量展示ADC的功能，代码中均没有使用宏定义，是为了看得更直观。</p>
<h3 id="独立模式单通道"><a href="#独立模式单通道" class="headerlink" title="独立模式单通道"></a>独立模式单通道</h3><p>**1) **初始 ADC 用到的 GPIO，这里我们以<code>GPIOC1</code>为例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ADCx_GPIO_Config</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 打开 ADC IO 端口时钟</span></span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC, ENABLE);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 配置 ADC IO 引脚模式</span></span><br><span class="line">	<span class="comment">// 必须为模拟输入</span></span><br><span class="line">	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_1;</span><br><span class="line">	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;</span><br><span class="line">	<span class="comment">// 初始化 ADC IO</span></span><br><span class="line">	GPIO_Init(GPIOC, &amp;GPIO_InitStructure); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2)</strong> 设置 ADC 的工作参数并初始化（以ADC1为例）；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ADCx_Mode_Config</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    ADC_InitTypeDef ADC_InitStructure;</span><br><span class="line">    <span class="comment">// 打开 ADC 时钟</span></span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1, ENABLE);</span><br><span class="line">    <span class="comment">// ADC 模式配置</span></span><br><span class="line">	<span class="comment">// 只使用一个 ADC，属于独立模式</span></span><br><span class="line">    ADC_InitStructure.ADC_Mode = ADC_Mode_Independent;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 禁止扫描模式，多通道才要，单通道不需要</span></span><br><span class="line">    ADC_InitStructure.ADC_ScanConvMode = DISABLE;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 连续转换模式</span></span><br><span class="line">    ADC_InitStructure.ADC_ContinuousConvMode = ENABLE;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 不用外部触发转换，软件开启即可</span></span><br><span class="line">    ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 转换结果右对齐</span></span><br><span class="line">    ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 转换通道 1 个</span></span><br><span class="line">    ADC_InitStructure.ADC_NbrOfChannel = <span class="number">1</span>;</span><br><span class="line">	<span class="comment">// 初始化 ADC</span></span><br><span class="line">	ADC_Init(ADC1, &amp;ADC_InitStructure);</span><br><span class="line">    <span class="comment">// 配置ADC时钟为PCLK2的8分频，即9MHz</span></span><br><span class="line">	RCC_ADCCLKConfig(RCC_PCLK2_Div8); </span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 配置 ADC 通道转换顺序和采样时间</span></span><br><span class="line">	ADC_RegularChannelConfig(ADC1, ADC_Channel_13, <span class="number">1</span>, ADC_SampleTime_55Cycles5);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * @param1 ADC 外设</span></span><br><span class="line"><span class="comment">      * @param2 通道选择</span></span><br><span class="line"><span class="comment">      * @param3 转换顺序 1~16</span></span><br><span class="line"><span class="comment">      * @param4 采样周期</span></span><br><span class="line"><span class="comment">	  */</span></span><br><span class="line">	<span class="comment">// ADC 转换结束产生中断，在中断服务程序中读取转换值</span></span><br><span class="line">	ADC_ITConfig(ADC1, ADC_IT_EOC, ENABLE);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 开启ADC，并开始转换</span></span><br><span class="line">	ADC_Cmd(ADC1, ENABLE);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 初始化ADC 校准寄存器  </span></span><br><span class="line">	ADC_ResetCalibration(ADC1);</span><br><span class="line">	<span class="comment">// 等待校准寄存器初始化完成</span></span><br><span class="line">	<span class="keyword">while</span>(ADC_GetResetCalibrationStatus(ADC1));</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// ADC开始校准</span></span><br><span class="line">	ADC_StartCalibration(ADC1);</span><br><span class="line">	<span class="comment">// 等待校准完成</span></span><br><span class="line">	<span class="keyword">while</span>(ADC_GetCalibrationStatus(ADC1));</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 由于没有采用外部触发，所以使用软件触发ADC转换 </span></span><br><span class="line">	ADC_SoftwareStartConvCmd(ADC1, ENABLE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>**3) **配置中断源和中断优先级；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ADC_NVIC_Config</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">  	NVIC_InitTypeDef NVIC_InitStructure;</span><br><span class="line">	<span class="comment">// 优先级分组</span></span><br><span class="line">	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_1);</span><br><span class="line"></span><br><span class="line">  	<span class="comment">// 配置中断优先级</span></span><br><span class="line"> 	NVIC_InitStructure.NVIC_IRQChannel = ADC1_2_IRQn;</span><br><span class="line">  	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = <span class="number">1</span>;</span><br><span class="line">  	NVIC_InitStructure.NVIC_IRQChannelSubPriority = <span class="number">1</span>;</span><br><span class="line">  	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;</span><br><span class="line">  	NVIC_Init(&amp;NVIC_InitStructure);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>4)</strong> 中断服务函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ADC1_2_IRQHandler</span><span class="params">(<span class="type">void</span>)</span>&#123;	</span><br><span class="line">	<span class="keyword">if</span> (ADC_GetITStatus(ADC1,ADC_IT_EOC)==SET) &#123;</span><br><span class="line">		<span class="comment">// 读取ADC的转换值</span></span><br><span class="line">		ADC_ConvertedValue = ADC_GetConversionValue(ADC1);</span><br><span class="line">        <span class="comment">// ADC_ConvertedValue为转换值，定义原型为：__IO uint16_t ADC_ConvertedValue;</span></span><br><span class="line">	&#125;</span><br><span class="line">	ADC_ClearITPendingBit(ADC1,ADC_IT_EOC);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>5)</strong> main()函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> __IO <span class="type">uint16_t</span> ADC_ConvertedValue;</span><br><span class="line"><span class="comment">// 局部变量，用于保存转换计算后的电压值 	 </span></span><br><span class="line"><span class="type">float</span> ADC_ConvertedValueLocal;   </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 默认已经完成了串口配置</span></span><br><span class="line">	USART_Config();</span><br><span class="line">	ADCx_GPIO_Config();</span><br><span class="line">	ADCx_Mode_Config();</span><br><span class="line">	ADC_NVIC_Config();</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\t\n ----这是一个串口发送实验----\r\n&quot;</span>);</span><br><span class="line">    ADC_ConvertedValueLocal =(<span class="type">float</span>) ADC_ConvertedValue/<span class="number">4096</span>*<span class="number">3.3</span>; </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\r\n The current AD value = 0x%04X \r\n&quot;</span>,ADC_ConvertedValue); </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\r\n The current AD value = %f V \r\n&quot;</span>,ADC_ConvertedValueLocal); </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\r\n\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="独立模式多通道"><a href="#独立模式多通道" class="headerlink" title="独立模式多通道"></a>独立模式多通道</h3><p>因为与单通道大多配置都相同，因此只列出差异部分。</p>
<p>**1) **初始 ADC 用到的 GPIO；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GPIO_InitStructure.GPIO_Pin = 	ADC_PIN1 | ADC_PIN2 | ADC_PIN3 | ADC_PIN4 | ADC_PIN5 | ADC_PIN6;</span><br></pre></td></tr></table></figure>

<p><strong>2)</strong> 设置 ADC 的工作参数并初始化，还需要对DMA进行配置；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">	DMA_InitTypeDef DMA_InitStructure;</span><br><span class="line">	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE);					<span class="comment">// 打开 DMA 时钟</span></span><br><span class="line">	DMA_InitStructure.DMA_PeripheralBaseAddr = (u32)(&amp;(ADC_x-&gt;DR));		<span class="comment">// 外设基址为：ADC 数据寄存器地址</span></span><br><span class="line">	DMA_InitStructure.DMA_MemoryBaseAddr = (u32)ADC_ConvertedValue;		<span class="comment">// 存储器地址,用户自定义变量（数组名）</span></span><br><span class="line">	DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralSRC;					<span class="comment">// 数据源来自外设</span></span><br><span class="line">	DMA_InitStructure.DMA_BufferSize = <span class="number">6</span>;								<span class="comment">// 缓冲区大小，应该等于数据目的地的数目大小</span></span><br><span class="line">	DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;	<span class="comment">// 外设寄存器只有一个，地址不用递增</span></span><br><span class="line">	DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable; 			<span class="comment">// 存储器地址递增</span></span><br><span class="line">	<span class="comment">// 外设数据大小为半字，即两个字节</span></span><br><span class="line">	DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_HalfWord;	</span><br><span class="line">	DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_HalfWord; <span class="comment">// 内存数据大小也为半字，跟外设数据大小相同</span></span><br><span class="line">	DMA_InitStructure.DMA_Mode = DMA_Mode_Circular;						<span class="comment">// 循环传输模式</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// DMA 传输通道优先级为高，当使用一个DMA通道时，优先级设置不影响</span></span><br><span class="line">	DMA_InitStructure.DMA_Priority = DMA_Priority_High;	</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 禁止存储器到存储器模式，因为是从外设到存储器</span></span><br><span class="line">	DMA_InitStructure.DMA_M2M = DMA_M2M_Disable;					</span><br><span class="line">	</span><br><span class="line">	DMA_Init(DMA1_Channel1, &amp;DMA_InitStructure);						<span class="comment">// 初始化DMA	</span></span><br><span class="line">	DMA_Cmd(DMA1_Channel1 , ENABLE);									<span class="comment">// 使能 DMA 通道</span></span><br><span class="line"><span class="comment">/* -------------------------------------------------------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line">	ADC_InitStructure.ADC_ScanConvMode = ENABLE;						<span class="comment">// 扫描模式 多通道</span></span><br><span class="line">	ADC_InitStructure.ADC_NbrOfChannel = <span class="number">6</span>;								<span class="comment">// 转换通道个数</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 配置ADC 通道的转换顺序和采样时间</span></span><br><span class="line">	ADC_RegularChannelConfig(ADC1, ADC_Channel_10, <span class="number">1</span>, ADC_SampleTime_55Cycles5);</span><br><span class="line">	ADC_RegularChannelConfig(ADC1, ADC_Channel_11, <span class="number">2</span>, ADC_SampleTime_55Cycles5);</span><br><span class="line">	ADC_RegularChannelConfig(ADC1, ADC_Channel_12, <span class="number">3</span>, ADC_SampleTime_55Cycles5);</span><br><span class="line">	ADC_RegularChannelConfig(ADC1, ADC_Channel_13, <span class="number">4</span>, ADC_SampleTime_55Cycles5);</span><br><span class="line">	ADC_RegularChannelConfig(ADC1, ADC_Channel_14, <span class="number">5</span>, ADC_SampleTime_55Cycles5);</span><br><span class="line">	ADC_RegularChannelConfig(ADC1, ADC_Channel_15, <span class="number">6</span>, ADC_SampleTime_55Cycles5);</span><br><span class="line">	</span><br><span class="line">	ADC_DMACmd(ADC1, ENABLE);											<span class="comment">// 使能ADC DMA 请求</span></span><br></pre></td></tr></table></figure>

<p><strong>3)</strong> main()函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ADC1转换的电压值通过DMA方式传到SRAM</span></span><br><span class="line"><span class="keyword">extern</span> __IO <span class="type">uint16_t</span> ADC_ConvertedValue[<span class="number">6</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 局部变量，用于保存转换计算后的电压值 	 </span></span><br><span class="line"><span class="type">float</span> ADC_ConvertedValueLocal[<span class="number">6</span>];         </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 默认已经完成了串口配置</span></span><br><span class="line">	USART_Config();</span><br><span class="line">	ADCx_GPIO_Config();</span><br><span class="line">	ADCx_Mode_Config();;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\t\n ----这是一个串口发送实验----\r\n&quot;</span>);</span><br><span class="line">    ADC_ConvertedValueLocal[<span class="number">0</span>] =(<span class="type">float</span>) ADC_ConvertedValue[<span class="number">0</span>]/<span class="number">4096</span>*<span class="number">3.3</span>;</span><br><span class="line">    ADC_ConvertedValueLocal[<span class="number">1</span>] =(<span class="type">float</span>) ADC_ConvertedValue[<span class="number">1</span>]/<span class="number">4096</span>*<span class="number">3.3</span>;</span><br><span class="line">    ADC_ConvertedValueLocal[<span class="number">2</span>] =(<span class="type">float</span>) ADC_ConvertedValue[<span class="number">2</span>]/<span class="number">4096</span>*<span class="number">3.3</span>;</span><br><span class="line">    ADC_ConvertedValueLocal[<span class="number">3</span>] =(<span class="type">float</span>) ADC_ConvertedValue[<span class="number">3</span>]/<span class="number">4096</span>*<span class="number">3.3</span>;</span><br><span class="line">    ADC_ConvertedValueLocal[<span class="number">4</span>] =(<span class="type">float</span>) ADC_ConvertedValue[<span class="number">4</span>]/<span class="number">4096</span>*<span class="number">3.3</span>;</span><br><span class="line">    ADC_ConvertedValueLocal[<span class="number">5</span>] =(<span class="type">float</span>) ADC_ConvertedValue[<span class="number">5</span>]/<span class="number">4096</span>*<span class="number">3.3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\r\n CH0 value = %f V \r\n&quot;</span>,ADC_ConvertedValueLocal[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\r\n CH1 value = %f V \r\n&quot;</span>,ADC_ConvertedValueLocal[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\r\n CH2 value = %f V \r\n&quot;</span>,ADC_ConvertedValueLocal[<span class="number">2</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\r\n CH3 value = %f V \r\n&quot;</span>,ADC_ConvertedValueLocal[<span class="number">3</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\r\n CH4 value = %f V \r\n&quot;</span>,ADC_ConvertedValueLocal[<span class="number">4</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\r\n CH5 value = %f V \r\n&quot;</span>,ADC_ConvertedValueLocal[<span class="number">5</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\r\n\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="双ADC同步规则"><a href="#双ADC同步规则" class="headerlink" title="双ADC同步规则"></a>双ADC同步规则</h3><p>**1) **初始 ADC 用到的 GPIO；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_1;</span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_4;</span><br></pre></td></tr></table></figure>

<p><strong>2)</strong> 设置 ADC 的工作参数并初始化，还需要对DMA进行配置；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">ADC_InitStructure.ADC_Mode = ADC_Mode_RegSimult;			<span class="comment">// 双ADC的规则同步</span></span><br><span class="line">ADC_InitStructure.ADC_ScanConvMode = ENABLE ; 				<span class="comment">// 扫描模式</span></span><br><span class="line">ADC_InitStructure.ADC_ContinuousConvMode = ENABLE;			<span class="comment">// 连续转换模式</span></span><br><span class="line"><span class="comment">// 不用外部触发转换，软件开启即可</span></span><br><span class="line">ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;</span><br><span class="line"></span><br><span class="line">ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;		<span class="comment">// 转换结果右对齐</span></span><br><span class="line">ADC_InitStructure.ADC_NbrOfChannel = <span class="number">1</span>;		       			<span class="comment">// 转换通道个数	</span></span><br><span class="line">ADC_Init(ADCx_1, &amp;ADC_InitStructure);						<span class="comment">// 初始化ADC			</span></span><br><span class="line">RCC_ADCCLKConfig(RCC_PCLK2_Div8); 							<span class="comment">// 配置ADC时钟PCLK2的8分频，即9MHz</span></span><br><span class="line"><span class="comment">// 配置ADC1 通道的转换顺序和采样时间</span></span><br><span class="line">ADC_RegularChannelConfig(ADC1, ADC_Channel_11, <span class="number">1</span>, ADC_SampleTime_239Cycles5);</span><br><span class="line">ADC_DMACmd(ADC1, ENABLE);									<span class="comment">// 使能ADC DMA 请求</span></span><br><span class="line"><span class="comment">// 由于没有采用外部触发，所以使用软件触发ADC转换 </span></span><br><span class="line">ADC_SoftwareStartConvCmd(ADCx_1, ENABLE);</span><br><span class="line"></span><br><span class="line">ADC_Init(ADC2, &amp;ADC_InitStructure);	</span><br><span class="line"><span class="comment">// 配置ADC2 通道的转换顺序和采样时间</span></span><br><span class="line">ADC_RegularChannelConfig(ADC2, ADC_Channel_14, <span class="number">1</span>, ADC_SampleTime_239Cycles5);</span><br><span class="line"></span><br><span class="line"> 	ADC_ExternalTrigConvCmd(ADC2, ENABLE);						<span class="comment">// 使能ADC2的外部触发转换</span></span><br></pre></td></tr></table></figure>

<p><strong>3)</strong> main()函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ADC1转换的电压值通过MDA方式传到SRAM</span></span><br><span class="line"><span class="keyword">extern</span> __IO <span class="type">uint32_t</span> ADC_ConvertedValue[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 局部变量，用于保存转换计算后的电压值 	 </span></span><br><span class="line"><span class="type">float</span> ADC_ConvertedValueLocal[NOFCHANEL*<span class="number">2</span>];        </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;		</span><br><span class="line">	<span class="type">uint16_t</span> temp0=<span class="number">0</span> ,temp1=<span class="number">0</span>;</span><br><span class="line">	USART_Config();						<span class="comment">// 默认已经完成了串口配置</span></span><br><span class="line">	ADCx_GPIO_Config();					<span class="comment">// GPIO 初始化</span></span><br><span class="line">	ADCx_Mode_Config();					<span class="comment">// ADC 初始化</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\r\n ----这是一个双ADC规则同步采集实验----\r\n&quot;</span>);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 取出ADC1数据寄存器的高16位，这个是ADC2的转换数据</span></span><br><span class="line">	temp0 = (ADC_ConvertedValue[<span class="number">0</span>]&amp;<span class="number">0XFFFF0000</span>) &gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="comment">// 取出ADC1数据寄存器的低16位，这个是ADC1的转换数据</span></span><br><span class="line">    temp1 = (ADC_ConvertedValue[<span class="number">0</span>]&amp;<span class="number">0XFFFF</span>);	</span><br><span class="line"></span><br><span class="line">    ADC_ConvertedValueLocal[<span class="number">0</span>] =(<span class="type">float</span>) temp0/<span class="number">4096</span>*<span class="number">3.3</span>;</span><br><span class="line">    ADC_ConvertedValueLocal[<span class="number">1</span>] =(<span class="type">float</span>) temp1/<span class="number">4096</span>*<span class="number">3.3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\r\n ADCx_1 value = %f V \r\n&quot;</span>, ADC_ConvertedValueLocal[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\r\n ADCx_2 value = %f V \r\n&quot;</span>, ADC_ConvertedValueLocal[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\r\n\r\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      </div>
      
        <div class="prev-or-next">
          <div class="post-foot-next">
            
              <a href="/2019/06/11/stm32-3/" target="_self">
                <i class="iconfont icon-chevronleft"></i>
                <span>Prev</span>
              </a>
            
          </div>
          <div class="post-attach">
            <span class="post-pubtime">
              <i class="iconfont icon-updatetime mr-10" title="Update time"></i>
              2019-06-17 23:12:43
            </span>
            
                  <span class="post-tags">
                    <i class="iconfont icon-tags mr-10" title="Tags"></i>
                    
                    <span class="span--tag mr-8">
                      <a href="/tags/STM32/" title="STM32">
                        #STM32
                      </a>
                    </span>
                    
                  </span>
              
          </div>
          <div class="post-foot-prev">
            
              <a href="/2019/06/29/git/" target="_self">
                <span>Next</span>
                <i class="iconfont icon-chevronright"></i>
              </a>
            
          </div>
        </div>
      
    </div>
    
  <div id="btn-catalog" class="btn-catalog">
    <i class="iconfont icon-catalog"></i>
  </div>
  <div class="post-catalog hidden" id="catalog">
    <div class="title">Contents</div>
    <div class="catalog-content">
      
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#ADC%E7%AE%80%E4%BB%8B"><span class="toc-text">ADC简介</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%B5%E5%8E%8B%E8%BE%93%E5%85%A5%E8%8C%83%E5%9B%B4"><span class="toc-text">电压输入范围</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E5%88%B6%E7%94%B5%E5%8E%8B%E8%8C%83%E5%9B%B4"><span class="toc-text">定制电压范围</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E9%80%9A%E9%81%93"><span class="toc-text">输入通道</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AC%E6%8D%A2%E9%A1%BA%E5%BA%8F"><span class="toc-text">转换顺序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A6%E5%8F%91%E6%BA%90"><span class="toc-text">触发源</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AC%E6%8D%A2%E6%97%B6%E9%97%B4"><span class="toc-text">转换时间</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ADC%E6%97%B6%E9%92%9F"><span class="toc-text">ADC时钟</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%87%E6%A0%B7%E6%97%B6%E9%97%B4"><span class="toc-text">采样时间</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-text">数据寄存器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%84%E5%88%99%E6%95%B0%E6%8D%AE%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-text">规则数据寄存器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E5%85%A5%E6%95%B0%E6%8D%AE%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-text">注入数据寄存器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD"><span class="toc-text">中断</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AC%E6%8D%A2%E7%BB%93%E6%9D%9F%E4%B8%AD%E6%96%AD"><span class="toc-text">转换结束中断</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E6%8B%9F%E7%9C%8B%E9%97%A8%E7%8B%97%E4%B8%AD%E6%96%AD"><span class="toc-text">模拟看门狗中断</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DMA-%E8%AF%B7%E6%B1%82"><span class="toc-text">DMA 请求</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C-ADC-%E6%A8%A1%E5%BC%8F"><span class="toc-text">双 ADC 模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BE%8B%E7%A8%8B%E8%AE%BE%E8%AE%A1"><span class="toc-text">例程设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8B%AC%E7%AB%8B%E6%A8%A1%E5%BC%8F%E5%8D%95%E9%80%9A%E9%81%93"><span class="toc-text">独立模式单通道</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8B%AC%E7%AB%8B%E6%A8%A1%E5%BC%8F%E5%A4%9A%E9%80%9A%E9%81%93"><span class="toc-text">独立模式多通道</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8CADC%E5%90%8C%E6%AD%A5%E8%A7%84%E5%88%99"><span class="toc-text">双ADC同步规则</span></a></li></ol></li></ol>
      
    </div>
  </div>

  
<script src="/js/catalog.js"></script>




    
      <div class="comments-container">
        







      </div>
    
  </div>


        
<div class="footer">
  <div class="social">
    <ul>
      
        <li>
          <a title="github" target="_blank" rel="noopener" href="https://github.com/zchengsite/hexo-theme-oranges">
            <i class="iconfont icon-github"></i>
          </a>
        </li>
      
    </ul>
  </div>
  
    
    <div class="footer-more">
      
        <a target="_blank" rel="noopener" href="https://github.com/zchengsite/hexo-theme-oranges">Copyright © 2024 Oranges</a>
        
    </div>
  
    
    <div class="footer-more">
      
        <a target="_blank" rel="noopener" href="https://github.com/zchengsite/hexo-theme-oranges">Theme by Oranges | Powered by Hexo</a>
        
    </div>
  
  
</div>

      </div>

      <div class="tools-bar">
        <div class="back-to-top tools-bar-item hidden">
  <a href="javascript: void(0)">
    <i class="iconfont icon-chevronup"></i>
  </a>
</div>


<script src="/js/backtotop.js"></script>



        
  <div class="search-icon tools-bar-item" id="search-icon">
    <a href="javascript: void(0)">
      <i class="iconfont icon-search"></i>
    </a>
  </div>

  <div class="search-overlay hidden">
    <div class="search-content" tabindex="0">
      <div class="search-title">
        <span class="search-icon-input">
          <a href="javascript: void(0)">
            <i class="iconfont icon-search"></i>
          </a>
        </span>
        
          <input type="text" class="search-input" id="search-input" placeholder="Search...">
        
        <span class="search-close-icon" id="search-close-icon">
          <a href="javascript: void(0)">
            <i class="iconfont icon-close"></i>
          </a>
        </span>
      </div>
      <div class="search-result" id="search-result"></div>
    </div>
  </div>

  <script type="text/javascript">
    var inputArea = document.querySelector("#search-input")
    var searchOverlayArea = document.querySelector(".search-overlay")

    inputArea.onclick = function() {
      getSearchFile()
      this.onclick = null
    }

    inputArea.onkeydown = function() {
      if(event.keyCode == 13)
        return false
    }

    function openOrHideSearchContent() {
      let isHidden = searchOverlayArea.classList.contains('hidden')
      if (isHidden) {
        searchOverlayArea.classList.remove('hidden')
        document.body.classList.add('hidden')
        // inputArea.focus()
      } else {
        searchOverlayArea.classList.add('hidden')
        document.body.classList.remove('hidden')
      }
    }

    function blurSearchContent(e) {
      if (e.target === searchOverlayArea) {
        openOrHideSearchContent()
      }
    }

    document.querySelector("#search-icon").addEventListener("click", openOrHideSearchContent, false)
    document.querySelector("#search-close-icon").addEventListener("click", openOrHideSearchContent, false)
    searchOverlayArea.addEventListener("click", blurSearchContent, false)

    var searchFunc = function (path, search_id, content_id) {
      'use strict';
      var $input = document.getElementById(search_id);
      var $resultContent = document.getElementById(content_id);
      $resultContent.innerHTML = "<ul><span class='local-search-empty'>First search, index file loading, please wait...<span></ul>";
      $.ajax({
        // 0x01. load xml file
        url: path,
        dataType: "xml",
        success: function (xmlResponse) {
          // 0x02. parse xml file
          var datas = $("entry", xmlResponse).map(function () {
            return {
              title: $("title", this).text(),
              content: $("content", this).text(),
              url: $("url", this).text()
            };
          }).get();
          $resultContent.innerHTML = "";

          $input.addEventListener('input', function () {
            // 0x03. parse query to keywords list
            var str = '<ul class=\"search-result-list\">';
            var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
            $resultContent.innerHTML = "";
            if (this.value.trim().length <= 0) {
              return;
            }
            // 0x04. perform local searching
            datas.forEach(function (data) {
              var isMatch = true;
              var content_index = [];
              if (!data.title || data.title.trim() === '') {
                data.title = "Untitled";
              }
              var orig_data_title = data.title.trim();
              var data_title = orig_data_title.toLowerCase();
              var orig_data_content = data.content.trim().replace(/<[^>]+>/g, "");
              var data_content = orig_data_content.toLowerCase();
              var data_url = data.url;
              var index_title = -1;
              var index_content = -1;
              var first_occur = -1;
              // only match artiles with not empty contents
              if (data_content !== '') {
                keywords.forEach(function (keyword, i) {
                  index_title = data_title.indexOf(keyword);
                  index_content = data_content.indexOf(keyword);

                  if (index_title < 0 && index_content < 0) {
                    isMatch = false;
                  } else {
                    if (index_content < 0) {
                      index_content = 0;
                    }
                    if (i == 0) {
                      first_occur = index_content;
                    }
                    // content_index.push({index_content:index_content, keyword_len:keyword_len});
                  }
                });
              } else {
                isMatch = false;
              }
              // 0x05. show search results
              if (isMatch) {
                str += "<li><a href='" + data_url + "' class='search-result-title'>" + orig_data_title + "</a>";
                var content = orig_data_content;
                if (first_occur >= 0) {
                  // cut out 100 characters
                  var start = first_occur - 20;
                  var end = first_occur + 80;

                  if (start < 0) {
                    start = 0;
                  }

                  if (start == 0) {
                    end = 100;
                  }

                  if (end > content.length) {
                    end = content.length;
                  }

                  var match_content = content.substr(start, end);

                  // highlight all keywords
                  keywords.forEach(function (keyword) {
                    var regS = new RegExp(keyword, "gi");
                    match_content = match_content.replace(regS, "<span class=\"search-keyword\">" + keyword + "</span>");
                  });

                  str += "<p class=\"search-result-abstract\">" + match_content + "...</p>"
                }
                str += "</li>";
              }
            });
            str += "</ul>";
            if (str.indexOf('<li>') === -1) {
              return $resultContent.innerHTML = "<ul><span class='local-search-empty'>No result<span></ul>";
            }
            $resultContent.innerHTML = str;
          });
        },
        error: function(xhr, status, error) {
          $resultContent.innerHTML = ""
          if (xhr.status === 404) {
            $resultContent.innerHTML = "<ul><span class='local-search-empty'>The search.xml file was not found, please refer to：<a href='https://github.com/zchengsite/hexo-theme-oranges#configuration' target='_black'>configuration</a><span></ul>";
          } else {
            $resultContent.innerHTML = "<ul><span class='local-search-empty'>The request failed, Try to refresh the page or try again later.<span></ul>";
          }
        }
      });
      $(document).on('click', '#search-close-icon', function() {
        $('#search-input').val('');
        $('#search-result').html('');
      });
    }

    var getSearchFile = function() {
        var path = "/search.xml";
        searchFunc(path, 'search-input', 'search-result');
    }
  </script>




        
  <div class="tools-bar-item theme-icon" id="switch-color-scheme">
    <a href="javascript: void(0)">
      <i id="theme-icon" class="iconfont icon-moon"></i>
    </a>
  </div>

  
<script src="/js/colorscheme.js"></script>





        
  
    <div class="share-icon tools-bar-item">
      <a href="javascript: void(0)" id="share-icon">
        <i class="iconfont iconshare"></i>
      </a>
      <div class="share-content hidden">
        
          <a class="share-item" href="https://twitter.com/intent/tweet?text=' + %E9%82%A3%E4%B8%AA%E5%88%9D%E5%A4%8F%E7%9A%84%E5%A4%9C%E6%99%9A%E2%80%94%E2%80%94%E4%B8%8EADC%E7%9A%84%E6%B5%AA%E6%BC%AB%E9%82%82%E9%80%85 + '&url=' + http%3A%2F%2Fblog.mahoo12138.cn%2F2019%2F06%2F17%2Fstm32-4%2F + '" target="_blank" title="Twitter">
            <i class="iconfont icon-twitter"></i>
          </a>
        
        
          <a class="share-item" href="https://www.facebook.com/sharer.php?u=http://blog.mahoo12138.cn/2019/06/17/stm32-4/" target="_blank" title="Facebook">
            <i class="iconfont icon-facebooksquare"></i>
          </a>
        
      </div>
    </div>
  
  
<script src="/js/shares.js"></script>



      </div>
    </div>
  </body>
</html>
