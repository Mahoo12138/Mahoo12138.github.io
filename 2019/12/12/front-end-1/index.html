<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><title>前端入门之ES5基本语法 [ Mahoo12138 ]</title><link rel="stylesheet" href="/css/index.css"><meta name="post"><link rel="stylesheet" href="/css/layouts/post.css"><meta name="generator" content="Hexo 7.3.0"></head><body><div id="hexo-container"><header></header><main id="content"><article id="post"><h1>前端入门之ES5基本语法</h1><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><h3 id="1-语句"><a href="#1-语句" class="headerlink" title="1. 语句"></a>1. 语句</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span> + <span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<p>语句：上述代码则是一行赋值语句，语句是为了完成某种任务而进行的操作；</p>
<p>表达式：<code>1 + 3</code>叫做表达式（expression），指一个为了得到返回值的计算式；</p>
<blockquote>
<p>区别在于，前者主要为了进行某种操作，一般情况下不需要返回值；后者则是为了得到返回值，一定会返回一个值。</p>
</blockquote>
<h3 id="2-变量"><a href="#2-变量" class="headerlink" title="2. 变量"></a>2. 变量</h3><p>变量是对“值”的具名引用。变量就是为“值”起名，然后引用这个名字，就等同于引用这个值。</p>
<p>变量的名字就是变量名，JavaScript 的变量名<strong>区分大小写</strong>；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;	<span class="comment">// 声明并复制</span></span><br><span class="line"><span class="keyword">var</span> b;			<span class="comment">// 声明</span></span><br><span class="line">b = <span class="number">1</span>;			<span class="comment">// 赋值</span></span><br></pre></td></tr></table></figure>

<p>如果只是声明变量而没有赋值，则该变量的值是<code>undefined</code>。<code>undefined</code>是一个特殊的值，表示“无定义”。</p>
<p>如果一个变量没有声明就直接使用，JavaScript 会报错，告诉你变量未定义（not defined）。</p>
<p>如果使用<code>var</code>重新声明一个已经存在的变量，是无效的；但如果第二次声明的时候还进行了赋值，则会覆盖掉前面的值。</p>
<p>JavaScript 引擎的工作方式是，先<strong>解析代码，获取所有被声明的变量，然后再一行一行地运行</strong>。这造成的结果，就是所有的变量的声明语句，都会被提升到代码的头部，这就叫做变量提升（hoisting）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>上述代码在运行时，并不会报错，而会显示 <code>a</code> 为 <code>undefined</code>，因为实际运行的代码如下，表示变量<code>a</code>已声明，但还未赋值：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line">a = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<h3 id="3-标识符"><a href="#3-标识符" class="headerlink" title="3. 标识符"></a>3. 标识符</h3><p>标识符（identifier）指的是用来识别各种值的合法名称。最常见的标识符就是变量名，以及函数名；</p>
<p>标识符命名规则如下。</p>
<ul>
<li>第一个字符，可以是任意 Unicode 字母（包括英文字母和其他语言的字母），以及美元符号（<code>$</code>）和下划线（<code>_</code>）。</li>
<li>第二个字符及后面的字符，除了 Unicode 字母、美元符号和下划线，还可以用数字<code>0-9</code>。</li>
</ul>
<blockquote>
<ul>
<li>中文是合法的标识符，可以用作变量名；</li>
<li>JavaScript 有一些保留字，不能用作标识符；</li>
</ul>
</blockquote>
<h3 id="4-注释"><a href="#4-注释" class="headerlink" title="4. 注释"></a>4. 注释</h3><p>历史上 JavaScript 可以兼容 HTML 代码的注释，所以<code>&lt;!--</code>和<code>--&gt;</code>也被视为合法的单行注释。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">1</span>; &lt;!-- x = <span class="number">2</span>;</span><br><span class="line">--&gt; x = <span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<p><code>--&gt;</code>只有在行首，才会被当成单行注释，否则会当作正常的运算；</p>
<h3 id="5-区块"><a href="#5-区块" class="headerlink" title="5. 区块"></a>5. 区块</h3><p>JavaScript 使用大括号，将多个相关的语句组合在一起，称为“区块”（block）。</p>
<p>对于<code>var</code>命令来说，JavaScript 的区块不构成单独的作用域（scope），也就是在区块外部，仍能访问到定义的变量；</p>
<h3 id="6-条件控制"><a href="#6-条件控制" class="headerlink" title="6. 条件控制"></a>6. 条件控制</h3><p><code>switch</code>语句后面的表达式，与<code>case</code>语句后面的表示式比较运行结果时，采用的是严格相等运算符（<code>===</code>），而不是相等运算符（<code>==</code>），这意味着比较时不会发生类型转换；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (x) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="attr">true</span>:</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;x 发生类型转换&#x27;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="attr">default</span>:</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;x 没有发生类型转换&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// x 没有发生类型转换</span></span><br></pre></td></tr></table></figure>

<p>由于变量<code>x</code>没有发生类型转换，所以不会执行<code>case true</code>的情况；</p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>JavaScript 的数据类型，共有六种。（ES6 又新增了第七种 Symbol 类型的值，暂不涉及。）</p>
<ul>
<li>数值（number）：整数和小数（比如<code>1</code>和<code>3.14</code>）。</li>
<li>字符串（string）：文本（比如<code>Hello World</code>）。</li>
<li>布尔值（boolean）：表示真伪的两个特殊值，即<code>true</code>（真）和<code>false</code>（假）。</li>
<li><code>undefined</code>：表示“未定义”或不存在，即由于目前没有定义，所以此处暂时没有任何值。</li>
<li><code>null</code>：表示空值，即此处的值为空。</li>
<li>对象（object）：各种值组成的集合。</li>
</ul>
<p>对象是最复杂的数据类型，又可以分成三个子类型。</p>
<ul>
<li>狭义的对象（object）</li>
<li>数组（array）</li>
<li>函数（function）</li>
</ul>
<h3 id="1-typeof-运算符"><a href="#1-typeof-运算符" class="headerlink" title="1. typeof 运算符"></a>1. typeof 运算符</h3><p>JavaScript 有三种方法，可以确定一个值到底是什么类型：</p>
<ul>
<li><code>typeof</code>运算符</li>
<li><code>instanceof</code>运算符</li>
<li><code>Object.prototype.toString</code>方法</li>
</ul>
<p><code>typeof</code>运算符可以返回一个值的数据类型。</p>
<p>数值、字符串、布尔值分别返回<code>number</code>、<code>string</code>、<code>boolean</code>，函数返回<code>function</code>，<code>undefined</code>返回<code>undefined</code>，利用这一点，<code>typeof</code>可以用来检查一个没有声明的变量，而不报错；</p>
<p>对象返回<code>object</code>，空数组（<code>[]</code>）的类型也是<code>object</code>，这表示在 JavaScript 内部，数组本质上只是一种特殊的对象。</p>
<blockquote>
<p><code>instanceof</code>运算符可以区分数组和对象:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> a = [];</span><br><span class="line"></span><br><span class="line">o <span class="keyword">instanceof</span> <span class="title class_">Array</span> <span class="comment">// false</span></span><br><span class="line">a <span class="keyword">instanceof</span> <span class="title class_">Array</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p><code>null</code>返回<code>object</code>，这是由于历史原因造成的，最初设计 JavaScript 时没有将<code>null</code>作为一种单独的数据类型，而是归为了一种特殊的<code>object</code>。</p>
<h3 id="2-null-和-undefined"><a href="#2-null-和-undefined" class="headerlink" title="2. null 和 undefined"></a>2. null 和 undefined</h3><p>一个变量被赋值为<code>undefined</code>和<code>null</code>，效果几乎等价，在<code>if</code>语句中，它们都会被自动转为<code>false</code>，相等运算符（<code>==</code>）甚至直接报告两者相等。</p>
<p><code>null</code>是一个表示“空”的对象，转为数值时为<code>0</code>；<code>undefined</code>是一个表示”此处无定义”的原始值，转为数值时为<code>NaN</code>。</p>
<ul>
<li><code>null</code>表示空值，即该处的值现在为空。调用函数时，某个参数未设置任何值，这时就可以传入<code>null</code>，表示该参数为空。</li>
<li><code>undefined</code>表示“未定义”，常见的场景有变量声明未定义，调用函数参数未提供，函数未返回值，对象没有赋值的属性；</li>
</ul>
<h3 id="3-布尔值"><a href="#3-布尔值" class="headerlink" title="3. 布尔值"></a>3. 布尔值</h3><p>如果 JavaScript 预期某个位置应该是布尔值，会将该位置上现有的值自动转为布尔值。转换规则是除了下面六个值被转为<code>false</code>，其他值都视为<code>true</code>。</p>
<ul>
<li><code>undefined</code></li>
<li><code>null</code></li>
<li><code>false</code></li>
<li><code>0</code></li>
<li><code>NaN</code></li>
<li><code>&quot;&quot;</code>或<code>&#39;&#39;</code>（空字符串）</li>
</ul>
<p>注意，空数组（<code>[]</code>）和空对象（<code>&#123;&#125;</code>）对应的布尔值，都是<code>true</code>；</p>
<h3 id="4-整数和浮点数"><a href="#4-整数和浮点数" class="headerlink" title="4. 整数和浮点数"></a>4. 整数和浮点数</h3><p>JavaScript 内部，所有数字都是以<strong>64位浮点数</strong>形式储存，即使整数也是如此。所以，<code>1</code>与<code>1.0</code>是相同的，是同一个数。</p>
<p>当需要整数才能完成计算时， JavaScript 会自动把64位浮点数，转成32位整数；</p>
<h4 id="4-1-数值精度"><a href="#4-1-数值精度" class="headerlink" title="4.1 数值精度"></a>4.1 数值精度</h4><p>根据国际标准 IEEE 754，JavaScript 浮点数的64个二进制位，从最左边开始，是这样组成的。</p>
<ul>
<li>第1位：符号位，<code>0</code>表示正数，<code>1</code>表示负数</li>
<li>第2位到第12位（共11位）：指数部分</li>
<li>第13位到第64位（共52位）：小数部分（即<strong>有效数字</strong>）</li>
</ul>
<p>符号位决定了一个数的正负，指数部分决定了数值的大小，小数部分决定了数值的精度。</p>
<p>指数部分一共有11个二进制位，大小范围就是0到2047。IEEE 754 规定，如果指数部分的值在0到2047之间（不含两个端点），那么有效数字的第一位默认总是1，<strong>不保存在64位浮点数之中</strong>。也就是说，有效数字这时总是<code>1.xx...xx</code>的形式，其中小数部分<code>xx...xx</code>的部分保存在64位浮点数之中，最长为52位。因此，JavaScript 提供的有效数字最长为53个二进制位，即精度最多只能到53个二进制位；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Math</span>.<span class="title function_">pow</span>(<span class="number">2</span>, <span class="number">53</span>)</span><br><span class="line"><span class="comment">// 9007199254740992</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">pow</span>(<span class="number">2</span>, <span class="number">53</span>) + <span class="number">1</span></span><br><span class="line"><span class="comment">// 9007199254740992</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">pow</span>(<span class="number">2</span>, <span class="number">53</span>) + <span class="number">2</span></span><br><span class="line"><span class="comment">// 9007199254740994</span></span><br></pre></td></tr></table></figure>

<p>超过这个范围的计算就无法保持精度了，也就是对十进制的15位数能保持精度。</p>
<h4 id="4-2-数值范围"><a href="#4-2-数值范围" class="headerlink" title="4.2 数值范围"></a>4.2 数值范围</h4><p>64位浮点数的指数部分的值最大为2047，分出一半表示负数，则 JavaScript 能够表示的数值范围为2^1024^到2^-1023^（开区间），超出这个范围的数无法表示。</p>
<ul>
<li>大于等于2的1024次方，那么就会发生“正向溢出”，这时就会返回<code>Infinity</code>；</li>
<li>如果一个数小于等于2的-1075次方（指数部分最小值-1023，再加上小数部分的52位），会发生为“负向溢出”，会直接返回 0；</li>
</ul>
<p>JavaScript 提供<code>Number</code>对象的<code>MAX_VALUE</code>和<code>MIN_VALUE</code>属性，返回可以表示的具体的最大值和最小值。</p>
<h4 id="4-3-数值的表示法"><a href="#4-3-数值的表示法" class="headerlink" title="4.3 数值的表示法"></a>4.3 数值的表示法</h4><p>科学计数法允许字母<code>e</code>或<code>E</code>的后面，跟着一个整数，表示这个数值的指数部分。以下情况会表示未科学计数法：</p>
<ul>
<li>小数点前的数字多于21位；</li>
<li>小数点后的零多于5个；</li>
</ul>
<h4 id="4-4-数值的进制"><a href="#4-4-数值的进制" class="headerlink" title="4.4 数值的进制"></a>4.4 数值的进制</h4><p>使用字面量（literal）直接表示一个数值时，JavaScript 对整数提供四种进制的表示方法：十进制、十六进制、八进制、二进制。</p>
<ul>
<li>十进制：没有前导0的数值。</li>
<li>八进制：有前缀<code>0o</code>或<code>0O</code>的数值，或者有前导0、且只用到0-7的八个阿拉伯数字的数值。</li>
<li>十六进制：有前缀<code>0x</code>或<code>0X</code>的数值。</li>
<li>二进制：有前缀<code>0b</code>或<code>0B</code>的数值。</li>
</ul>
<p>默认情况下，JavaScript 内部会自动将八进制、十六进制、二进制转为十进制。</p>
<h3 id="5-特殊数值"><a href="#5-特殊数值" class="headerlink" title="5. 特殊数值"></a>5. 特殊数值</h3><p>JavaScript 内部实际上存在2个<code>0</code>：一个是<code>+0</code>，一个是<code>-0</code>，区别就是64位浮点数表示法的符号位不同。它们是等价的。</p>
<p>唯一有区别的场合是，<code>+0</code>或<code>-0</code>当作分母，返回的值是不相等的，除以正零得到<code>+Infinity</code>，除以负零得到<code>-Infinity</code>；</p>
<p><code>NaN</code>，表示“非数字”（Not a Number），主要出现在<strong>将字符串解析成数字出错</strong>的场合，逻辑错误的数学函数的运算结果也会出现<code>NaN</code>；</p>
<p><code>NaN</code>不是独立的数据类型，而是一个特殊数值，它的数据类型依然属于<code>Number</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="title class_">NaN</span> <span class="comment">// &#x27;number&#x27;</span></span><br></pre></td></tr></table></figure>

<p><code>NaN</code>不等于任何值，包括它本身，<code>NaN</code>与任何数（包括它自己）的运算，得到的都是<code>NaN</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">NaN</span> === <span class="title class_">NaN</span> <span class="comment">// false</span></span><br><span class="line"><span class="title class_">NaN</span> + <span class="number">2</span> 		<span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>

<p><code>Infinity</code>表示“无穷”，用来表示两种场景。一种是一个正的数值太大，或一个负的数值太小，无法表示；另一种是非 0 数值除以 0，得到<code>Infinity</code>。</p>
<p><code>Infinity</code>大于一切数值（除了<code>NaN</code>），<code>-Infinity</code>小于一切数值（除了<code>NaN</code>），<code>Infinity</code>与<code>NaN</code>比较，总是返回<code>false</code>；</p>
<p>0 乘以<code>Infinity</code>，返回<code>NaN</code>；0除以<code>Infinity</code>，返回<code>0</code>；<code>Infinity</code>除以0，返回<code>Infinity</code>；</p>
<p><code>Infinity</code>与<code>null</code>计算时，<code>null</code>会转成0，等同于与<code>0</code>的计算，<code>Infinity</code>与<code>undefined</code>计算，返回的都是<code>NaN</code>；</p>
<h3 id="6-字符串"><a href="#6-字符串" class="headerlink" title="6. 字符串"></a>6. 字符串</h3><p>单引号字符串的内部，可以使用双引号。双引号字符串的内部，可以使用单引号，同种引号包含需带上<code>\</code>转义；</p>
<p>由于 HTML 语言的属性值使用双引号，所以很多项目约定 JavaScript 语言的字符串只使用单引号；</p>
<p>字符串默认只能写在一行内，分成多行将会报错，可以在每一行的尾部使用反斜杠换行；</p>
<p>字符串可以被视为字符数组，因此可以使用数组的方括号运算符，用来返回某个位置的字符。</p>
<p>与数组的相似性仅此而已，字符串内部的单个字符无法改变和增删；</p>
<p>JavaScript 使用 Unicode 字符集。JavaScript 引擎内部，所有字符都用 Unicode 表示。</p>
<p>每个字符在 JavaScript 内部都是以16位（即2个字节）的 UTF-16 格式储存。也就是说，JavaScript 的单位字符长度固定为16位长度，即<strong>2个字节</strong>。</p>
<p>但是，UTF-16 有两种长度：对于码点在<code>U+0000</code>到<code>U+FFFF</code>之间的字符，长度为16位（即2个字节）；对于码点在<code>U+10000</code>到<code>U+10FFFF</code>之间的字符，长度为32位（即4个字节），而且前两个字节在<code>0xD800</code>到<code>0xDBFF</code>之间，后两个字节在<code>0xDC00</code>到<code>0xDFFF</code>之间。举例来说，码点<code>U+1D306</code>对应的字符为<code>𝌆，</code>它写成 UTF-16 就是<code>0xD834 0xDF06</code>。</p>
<p>JavaScript 对 UTF-16 的支持是不完整的，由于历史原因，只支持两字节的字符，不支持四字节的字符。</p>
<h3 id="7-对象"><a href="#7-对象" class="headerlink" title="7. 对象"></a>7. 对象</h3><p>什么是对象？简单说，对象就是一组“键值对”（key-value）的集合，是一种无序的复合数据集合。</p>
<p>对象的所有<strong>键名都是字符串</strong>（ES6 又引入了 Symbol 值也可以作为键名），所以<strong>加不加引号都可以</strong>，会被自动转为字符串；</p>
<p>如果键名不符合标识名的条件，且也不是数字，则必须加上引号，否则会报错；</p>
<p>对象的每一个键名又称为“<strong>属性</strong>”（property），它的“键值”可以是任何数据类型，属性可以动态创建，不必在对象声明时就指定；</p>
<p>如果不同的变量名指向同一个对象，那么它们都是这个对象的引用，也就是说指向同一个内存地址。修改其中一个变量，会影响到其他所有变量。</p>
<p>但是，这种引用只局限于对象，如果两个变量指向同一个原始类型的值。那么，变量这时都是值的拷贝。</p>
<p>对象采用大括号表示，这导致了一个问题：如果行首是一个大括号，它到底是表达式还是语句？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attr">foo</span>: <span class="number">123</span> &#125;</span><br></pre></td></tr></table></figure>

<p>为了避免这种歧义，当无法确定是对象还是代码块，一律解释为代码块。</p>
<p>如果要解释为对象，<strong>最好在大括号前加上圆括号</strong>。因为圆括号的里面，只能是表达式，所以确保大括号只能解释为对象。</p>
<p>数值键名不能使用点运算符（因为会被当成小数点），只能使用方括号运算符</p>
<p>查看一个对象本身的所有属性，可以使用<code>Object.keys</code>方法。</p>
<p><code>delete</code>命令用于删除对象的属性需要注意的是，<code>delete</code>命令只能删除对象本身的属性，无法删除继承的属性；</p>
<p><code>in</code>运算符用于检查对象是否包含某个属性，但它不能识别哪些属性是对象自身的，哪些属性是继承的，可以使用对象的<code>hasOwnProperty</code>方法判断一下，是否为对象自身的属性</p>
<p><code>for...in</code>循环用来遍历一个对象的全部属性：</p>
<ul>
<li>它遍历的是对象所有可遍历（enumerable）的属性，会跳过不可遍历的属性。</li>
<li>它不仅遍历对象自身的属性，还遍历继承的属性。</li>
</ul>
<p><code>with</code>语句是操作同一个对象的多个属性时，提供一些书写的方便：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">p1</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">p2</span>: <span class="number">2</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title function_">with</span> (obj) &#123;</span><br><span class="line">  p1 = <span class="number">4</span>;</span><br><span class="line">  p2 = <span class="number">5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，如果<code>with</code>区块内部有变量的赋值操作，必须是当前对象已经存在的属性，否则会创造一个当前作用域的全局变量。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="title function_">with</span> (obj) &#123;</span><br><span class="line">  p1 = <span class="number">4</span>;</span><br><span class="line">  p2 = <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 对象obj并没有p1属性，对p1赋值等于创造了一个全局变量p1 */</span></span><br><span class="line">obj.<span class="property">p1</span> <span class="comment">// undefined</span></span><br><span class="line">p1 		<span class="comment">// 4</span></span><br></pre></td></tr></table></figure>

<p>因为<code>with</code>区块没有改变作用域，它的内部依然是当前作用域。这造成了<code>with</code>语句的一个很大的弊病，就是绑定对象不明确；因此，建议不要使用<code>with</code>语句。</p>
<h3 id="8-函数"><a href="#8-函数" class="headerlink" title="8. 函数"></a>8. 函数</h3><h4 id="8-1-声明方法"><a href="#8-1-声明方法" class="headerlink" title="8.1 声明方法"></a>8.1 声明方法</h4><p><strong>（1）function 命令</strong></p>
<p><code>function</code>命令声明的代码区块，就是一个函数。<code>function</code>命令后面是函数名，函数名后面是一对圆括号，里面是传入函数的参数。函数体放在大括号里面。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">print</span>(<span class="params">s</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码命名了一个<code>print</code>函数，以后使用<code>print()</code>这种形式，就可以调用相应的代码。这叫做函数的声明（Function Declaration）。</p>
<p><strong>（2）函数表达式</strong></p>
<p>除了用<code>function</code>命令声明函数，还可以采用变量赋值的写法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> print = <span class="keyword">function</span>(<span class="params">s</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(s);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这种写法将一个匿名函数赋值给变量。这时，这个匿名函数又称<strong>函数表达式</strong>（Function Expression），因为赋值语句的等号右侧只能放表达式。</p>
<p>采用函数表达式声明函数时，<code>function</code>命令后面不带有函数名。<strong>如果加上函数名，该函数名只在函数体内部有效，在函数体外部无效。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> print = <span class="keyword">function</span> <span class="title function_">x</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> x);</span><br><span class="line">&#125;;</span><br><span class="line">x</span><br><span class="line"><span class="comment">// ReferenceError: x is not defined</span></span><br><span class="line"><span class="title function_">print</span>()</span><br><span class="line"><span class="comment">// function</span></span><br></pre></td></tr></table></figure>

<p>这种写法的用处有两个，一是可以在函数体内部调用自身，二是方便除错（除错工具显示函数调用栈时，将显示函数名，而不再显示这里是一个匿名函数）。因此，下面的形式声明函数也非常常见。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，函数的表达式需要在语句的结尾加上分号，表示语句结束。而函数的声明在结尾的大括号后面不用加分号。总的来说，这两种声明函数的方式，差别很细微，可以近似认为是等价的。</p>
<p><strong>（3）Function 构造函数</strong></p>
<p>通过传递任意数量的参数给<code>Function</code>构造函数，只有最后一个参数会被当做函数体，如果只有一个参数，该参数就是函数体，这种声明函数的方式非常不直观，几乎无人使用。</p>
<h4 id="8-2-函数提升"><a href="#8-2-函数提升" class="headerlink" title="8.2 函数提升"></a>8.2 函数提升</h4><p><strong>如果同一个函数被多次声明，后面的声明就会覆盖前面的声明。</strong></p>
<p>函数可以调用自身，这就是递归（recursion）。</p>
<p>JavaScript 语言将函数看作一种值，只是一个可以执行的值，此外并无特殊之处；</p>
<p>JavaScript 引擎将函数名视同变量名，所以采用<code>function</code>命令声明函数时，整个函数会像<strong>变量声明</strong>一样，被提升到代码头部；</p>
<p>用<code>function</code>命令和<code>var</code>赋值语句声明同一个函数，由于存在函数提升，最后会采用<code>var</code>赋值语句的定义。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(f); <span class="comment">// function f() &#123; console.log(&#x27;2&#x27;);&#125;</span></span><br><span class="line"><span class="title function_">f</span>()	<span class="comment">// 2</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;2&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">f</span>() <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>函数提升要比变量提升的优先级要高一些，且不会被变量声明覆盖，但是会被变量赋值之后覆盖。</p>
<p>函数的<code>name</code>属性返回函数的名字，如果是通过变量赋值定义的（匿名）函数，那么<code>name</code>属性返回变量名；</p>
<p>函数的<code>length</code>属性返回函数预期传入的参数个数，函数的<code>toString()</code>方法返回一个字符串，内容是函数的源码</p>
<h4 id="8-3-作用域"><a href="#8-3-作用域" class="headerlink" title="8.3 作用域"></a>8.3 作用域</h4><p><strong>作用域（scope）指的是变量存在的范围</strong>。在 ES5 的规范中，JavaScript 只有两种作用域：</p>
<ul>
<li>全局作用域，变量在整个程序中一直存在，所有地方都可以读取；</li>
<li>函数作用域，变量只在函数内部存在；</li>
</ul>
<p>对于顶层函数来说，函数外部声明的变量就是全局变量（global variable），它可以在函数内部读取；</p>
<p>在函数内部定义的变量，<strong>外部无法读取</strong>，称为“局部变量”（local variable）；</p>
<p>函数内部定义的变量，会在该作用域内覆盖同名全局变量；</p>
<p>对于<code>var</code>命令来说，局部变量只能在函数内部声明，在其他区块中声明，一律都是全局变量；</p>
<h4 id="8-4-函数内部的变量提升"><a href="#8-4-函数内部的变量提升" class="headerlink" title="8.4 函数内部的变量提升"></a>8.4 函数内部的变量提升</h4><p><code>var</code>命令声明的变量，不管在什么位置，变量声明都会被<strong>提升到函数体的头部</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">x</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (x &gt; <span class="number">100</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> tmp = x - <span class="number">100</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">x</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> tmp;</span><br><span class="line">  <span class="keyword">if</span> (x &gt; <span class="number">100</span>) &#123;</span><br><span class="line">    tmp = x - <span class="number">100</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="8-5-函数本身的作用域"><a href="#8-5-函数本身的作用域" class="headerlink" title="8.5 函数本身的作用域"></a>8.5 函数本身的作用域</h4><p>函数本身也是一个值，也有自己的作用域。它的作用域与变量一样，就是其声明时所在的作用域，与其运行时所在的作用域无关，也就是说函数执行时所在的作用域，是定义时的作用域，而不是调用时所在的作用域：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> x = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">  <span class="title function_">x</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">f</span>() <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，函数<code>x</code>是在函数<code>f</code>的外部声明的，所以它的作用域绑定外层，内部变量<code>a</code>不会到函数<code>f</code>体内取值，所以输出<code>1</code>，而不是<code>2</code>。</p>
<p>同样的，函数体内部声明的函数，作用域绑定函数体内部。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> bar;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> f = <span class="title function_">foo</span>();</span><br><span class="line"><span class="title function_">f</span>() <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<h4 id="8-6-函数的参数"><a href="#8-6-函数的参数" class="headerlink" title="8.6 函数的参数"></a>8.6 函数的参数</h4><p>函数参数不是必需的，JavaScript 允许省略参数，省略的参数的值就变为<code>undefined</code>；</p>
<p>函数参数如果是原始类型的值（数值、字符串、布尔值），传递方式是传值传递（passes by value）。这意味着，在函数体内修改参数值，不会影响到函数外部。</p>
<p>如果函数参数是复合类型的值（数组、对象、其他函数），传递方式是传址传递（pass by reference）。也就是说，传入函数的原始值的地址，因此在函数内部修改参数，将会影响到原始值。</p>
<p>如果函数内部修改的，不是参数对象的某个属性，而是替换掉整个参数，这时不会影响到原始值。</p>
<p>如果有同名的参数，则取最后出现的那个值，这时，如果要获得前面的值，可以使用<code>arguments</code>对象，例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">a, a</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">f</span>(<span class="number">1</span>) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<h4 id="8-7-闭包"><a href="#8-7-闭包" class="headerlink" title="8.7 闭包"></a>8.7 闭包</h4><p>在理解了变量作用域之后，就能很快理解闭包了。</p>
<p>正常情况下，函数外部无法读取函数内部声明的变量。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> n = <span class="number">999</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(n)</span><br><span class="line"><span class="comment">// Uncaught ReferenceError: n is not defined</span></span><br></pre></td></tr></table></figure>

<p>那就是在函数的内部，再定义一个函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> n = <span class="number">999</span>;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">f2</span>(<span class="params"></span>) &#123;</span><br><span class="line">　　<span class="variable language_">console</span>.<span class="title function_">log</span>(n); <span class="comment">// 999</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>数<code>f2</code>就在函数<code>f1</code>内部，这时<code>f1</code>内部的所有局部变量，对<code>f2</code>都是可见的。既然<code>f2</code>可以读取<code>f1</code>的局部变量，那么只要把<code>f2</code>作为返回值，就可以在<code>f1</code>外部读取它的内部变量了。</p>
<p>由于在 JavaScript 语言中，只有函数内部的子函数才能读取内部变量，因此可以把闭包简单理解成“<strong>定义在一个函数内部的函数</strong>”。闭包最大的特点，就是它可以“记住”诞生的环境；</p>
<p>闭包的最大用处有两个，一个是可以<strong>读取外层函数内部的变量</strong>，另一个就是<strong>让这些变量始终保持在内存中</strong>，即闭包可以使得它诞生环境一直存在。请看下面的例子，闭包使得内部变量记住上一次调用时的运算结果。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createIncrementor</span>(<span class="params">start</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> start++;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> inc = <span class="title function_">createIncrementor</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">inc</span>() <span class="comment">// 5</span></span><br><span class="line"><span class="title function_">inc</span>() <span class="comment">// 6</span></span><br><span class="line"><span class="title function_">inc</span>() <span class="comment">// 7</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>start</code>是函数<code>createIncrementor</code>的内部变量。通过闭包，<code>start</code>的状态被保留了，每一次调用都是在上一次调用的基础上进行计算。从中可以看到，闭包<code>inc</code>使得函数<code>createIncrementor</code>的内部环境，一直存在。所以，闭包可以看作是函数内部作用域的一个接口。</p>
<p>为什么闭包能够返回外层函数的内部变量？原因是闭包用到了外层变量（<code>start</code>），导致外层函数（<code>createIncrementor</code>）不能从内存释放。只要闭包没有被垃圾回收机制清除，外层函数提供的运行环境也不会被清除，它的内部变量就始终保存着当前值，供闭包读取。</p>
<p>闭包的另一个用处，是封装对象的私有属性和私有方法；</p>
<p>外层函数每次运行，都会生成一个新的闭包，而这个闭包又会保留外层函数的内部变量，所以内存消耗很大。因此不能滥用闭包，否则会造成网页的性能问题。</p>
<h4 id="8-8-立即调用的函数表达式（IIFE）"><a href="#8-8-立即调用的函数表达式（IIFE）" class="headerlink" title="8.8 立即调用的函数表达式（IIFE）"></a>8.8 立即调用的函数表达式（IIFE）</h4><p>JavaScript 的语法，圆括号<code>()</code>跟在函数名之后，表示调用该函数。</p>
<p>在定义函数之后，立即调用该函数，会产生语法错误；当作表达式时，函数可以定义后直接加圆括号调用：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>(<span class="params"></span>)&#123; <span class="comment">/* code */</span> &#125;();</span><br><span class="line"><span class="comment">// SyntaxError: Unexpected token</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>)&#123; <span class="keyword">return</span> <span class="number">1</span>&#125;();</span><br><span class="line">f <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>为了避免解析的歧义，JavaScript 规定，如果<code>function</code>关键字出现在行首，一律解释成语句。因此，引擎看到行首是<code>function</code>关键字之后，认为这一段都是函数的定义，不应该以圆括号结尾，所以就报错了。</p>
<p>函数定义后立即调用的解决方法，就是不要让<code>function</code>出现在行首，让引擎将其理解成一个表达式。最简单的处理，就是将其放在一个圆括号里面：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span>(<span class="params"></span>)&#123; <span class="comment">/* code */</span> &#125;());</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line">(<span class="keyword">function</span>(<span class="params"></span>)&#123; <span class="comment">/* code */</span> &#125;)();</span><br></pre></td></tr></table></figure>

<p>这就叫做“<strong>立即调用的函数表达式</strong>”（Immediately-Invoked Function Expression），简称 IIFE。</p>
<p>上述代码若没有分号隔开，JavaScript 会将它们连在一起解释，<strong>将第二行解释为第一行的参数</strong>。</p>
<p>通常情况下，只对匿名函数使用这种“立即执行的函数表达式”。它的目的有两个：</p>
<ul>
<li><p>一是不必为函数命名，避免了污染全局变量；</p>
</li>
<li><p>二是 IIFE 内部形成了一个单独的作用域，可以封装一些外部无法读取的私有变量。</p>
</li>
</ul>
<h4 id="8-9-eval-命令"><a href="#8-9-eval-命令" class="headerlink" title="8.9 eval 命令"></a>8.9 eval 命令</h4><p><code>eval</code>命令接受一个字符串作为参数，并将这个字符串当作语句执行。</p>
<p><code>eval</code>没有自己的作用域，都在当前作用域内执行，因此可能会修改当前作用域的变量的值，造成安全问题。</p>
<p>为了防止这种风险，JavaScript 规定，如果使用严格模式，<code>eval</code>内部声明的变量，<strong>不会影响到外部作用域</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="string">&#x27;use strict&#x27;</span>;</span><br><span class="line">  <span class="built_in">eval</span>(<span class="string">&#x27;var foo = 123&#x27;</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(foo);  <span class="comment">// ReferenceError: foo is not defined</span></span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>

<p>严格模式下，<code>eval</code>内部还是改写了外部变量，可见安全风险依然存在。</p>
<p>总之，<code>eval</code>的本质是在当前作用域之中，注入代码。由于安全风险和不利于 JavaScript 引擎优化执行速度，一般不推荐使用。通常情况下，<code>eval</code>最常见的场合是解析 JSON 数据的字符串，不过正确的做法应该是使用原生的<code>JSON.parse</code>方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m = <span class="built_in">eval</span>;</span><br><span class="line"><span class="title function_">m</span>(<span class="string">&#x27;var x = 1&#x27;</span>);</span><br><span class="line">x <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，变量<code>m</code>是<code>eval</code>的别名。静态代码分析阶段，引擎分辨不出<code>m(&#39;var x = 1&#39;)</code>执行的是<code>eval</code>命令。</p>
<p>为了保证<code>eval</code>的别名不影响代码优化，JavaScript 的标准规定，凡是使用别名执行<code>eval</code>，<code>eval</code>内部一律是全局作用域。</p>
<h3 id="9-数组"><a href="#9-数组" class="headerlink" title="9. 数组"></a>9. 数组</h3><p>本质上，数组属于一种特殊的对象。</p>
<p>数组的特殊性体现在，它的键名是按次序排列的一组整数（0，1，2…）。</p>
<p>对于数值的键名，不能使用点结构。</p>
<p>JavaScript 使用一个32位整数，保存数组的元素个数。这意味着，数组成员最多只有 4294967295 个（2^32^ - 1）个，也就是说<code>length</code>属性的最大值就是 4294967295。</p>
<p><code>length</code>属性是一个动态的值，等于键名中的最大整数加上 1，数组的数字键不需要连续，这也表明数组是一种动态的数据结构，可以随时增减数组的成员。</p>
<p><code>length</code>属性是可写的，若设置小于原有的大小，数组会动态减少；清空数组的一个有效方法，就是将<code>length</code>属性设为 0。</p>
<p><code>for...in</code>不仅会遍历数组所有的数字键，还会遍历非数字键，所以数组的遍历可以考虑使用<code>for</code>循环或<code>while</code>循环。</p>
<h4 id="9-1-数组的空位"><a href="#9-1-数组的空位" class="headerlink" title="9.1 数组的空位"></a>9.1 数组的空位</h4><p>当数组的某个位置是空元素，即两个逗号之间没有任何值，我们称该数组存在空位（hole）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, , <span class="number">1</span>];</span><br><span class="line">a.<span class="property">length</span> <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>上面代码表明，数组的空位不影响<code>length</code>属性。</p>
<p>数组的空位是可以读取的，返回<code>undefined</code>，使用<code>delete</code>命令删除一个数组成员，会形成空位，并且不会影响<code>length</code>属性。</p>
<p>数组的某个位置是空位，与某个位置是<code>undefined</code>，是不一样的。如果是空位，使用数组的<code>forEach</code>方法、<code>for...in</code>结构、以及<code>Object.keys</code>方法进行遍历，空位都会被跳过。</p>
<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p>加法运算符<code>+</code>是在运行时决定，到底是执行相加，还是执行连接。也就是说，运算子的不同，导致了不同的语法行为，这种现象称为“重载”（overload）。</p>
<p>如果运算子是对象，必须先转成原始类型的值，然后再相加：</p>
<ul>
<li>自动调用对象的<code>valueOf</code>方法，总是返回对象自身；</li>
<li>自动调用对象的<code>toString</code>方法，将其转为字符串；</li>
</ul>
<p>如果运算子是一个<code>Date</code>对象的实例，那么会优先执行<code>toString</code>方法。</p>
<p>余数运算符的运算结果的正负号由第一个运算子的正负号决定；</p>
<p><code>+</code>数值运算符的作用在于可以将任何值转为数值（与<code>Number</code>函数的作用相同），<code>-</code> 负数值运算符效果一致，不过符号相反，数值运算符号和负数值运算符，都会返回一个新的值，而不会改变原始变量的值；</p>
<p>数运算符（<code>**</code>）完成指数运算，前一个运算子是底数，后一个运算子是指数；</p>
<p>指数运算符是右结合，而不是左结合。即多个指数运算符连用时，先进行最右边的计算；</p>
<h3 id="1-比较运算符"><a href="#1-比较运算符" class="headerlink" title="1. 比较运算符"></a>1. 比较运算符</h3><p>字符串的比较进行比较时是按照字典顺序进行比较，JavaScript 引擎内部首先比较首字符的 Unicode 码点；</p>
<p>非字符串的比较，其中至少一个是字符串，原始类型值则转换为数字对比，对象先转为原始类型再执行<code>toString</code>方法；</p>
<p>JavaScript 提供两种相等运算符：<code>==</code>和<code>===</code>。</p>
<p>简单说，它们的区别是相等运算符（<code>==</code>）比较<strong>两个值是否相等</strong>，严格相等运算符（<code>===</code>）比较它们<strong>是否为“同一个值”</strong>。</p>
<p>如果两个值不是同一类型，严格相等运算符（<code>===</code>）直接返回<code>false</code>，而相等运算符（<code>==</code>）会<strong>将它们转换成同一个类型</strong>，再用严格相等运算符进行比较；</p>
<ul>
<li><p>如果两个值的类型不同，直接返回<code>false</code>。</p>
</li>
<li><p>同一类型的原始类型的值（数值、字符串、布尔值）比较时，值相同就返回<code>true</code>，值不同就返回<code>false</code>。</p>
</li>
<li><p>两个复合类型（对象、数组、函数）的数据比较时，不是比较它们的值是否相等，而是比较它们是否指向同一个地址；</p>
</li>
<li><p><code>undefined</code>和<code>null</code>与自身严格相等，变量声明后默认值是<code>undefined</code>，因此两个只声明未赋值的变量是相等的；</p>
</li>
</ul>
<p>相等运算符<code>==</code>用来比较相同类型的数据时，与严格相等运算符完全一样。</p>
<ul>
<li>原始类型的值会转换成数值再进行比较；</li>
<li>对象（这里指广义的对象，包括数组和函数）与原始类型的值比较时，对象转换成原始类型的值，再进行比较；</li>
<li><code>undefined</code>和<code>null</code>只有与自身比较，或者互相比较时，才会返回<code>true</code>；与其他类型的值比较时，结果都为<code>false</code>。</li>
</ul>
<h3 id="2-布尔运算符"><a href="#2-布尔运算符" class="headerlink" title="2. 布尔运算符"></a>2. 布尔运算符</h3><p>对于非布尔值，取反运算符会将其转为布尔值。可以这样记忆，以下六个值取反后为<code>true</code>，其他值都为<code>false</code>。</p>
<ul>
<li><code>undefined</code></li>
<li><code>null</code></li>
<li><code>false</code></li>
<li><code>0</code></li>
<li><code>NaN</code></li>
<li>空字符串（<code>&#39;&#39;</code>）</li>
</ul>
<p>如果对一个值连续做两次取反运算，等于将其转为对应的布尔值，与<code>Boolean</code>函数的作用相同。</p>
<p>且运算符（<code>&amp;&amp;</code>）往往用于多个表达式的求值：</p>
<ul>
<li><p>如果第一个运算子的布尔值为<code>true</code>，则返回第二个运算子的值（注意是值，不是布尔值）；</p>
</li>
<li><p>如果第一个运算子的布尔值为<code>false</code>，则直接返回第一个运算子的值，且不再对第二个运算子求值。</p>
</li>
</ul>
<p>跳过第二个运算子的机制，被称为“短路”。可用短路代替<code>if</code>语句；</p>
<p>且运算符可以多个连用，这时返回第<strong>一个布尔值</strong>为<code>false</code>的表达式的值。如果所有表达式的布尔值都为<code>true</code>，则返回最后一个表达式的值。</p>
<p>或运算符（<code>||</code>）如果第一个运算子的布尔值为<code>true</code>，则返回第一个运算子的值，且不再对第二个运算子求值；如果第一个运算子的布尔值为<code>false</code>，则返回第二个运算子的值。</p>
<p>或运算符常用于为变量设置默认值：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">text = text || <span class="string">&#x27;&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="3-二进制运算符"><a href="#3-二进制运算符" class="headerlink" title="3. 二进制运算符"></a>3. 二进制运算符</h3><p>位运算符只对整数起作用，如果一个运算子不是整数，<strong>会自动转为整数后再执行</strong>。另外，虽然在 JavaScript 内部，数值都是以64位浮点数的形式储存，但是做位运算的时候，是以32位带符号的整数进行运算的，并且返回值也是一个32位带符号的整数；</p>
<p>位运算只对整数有效，遇到小数时，会将小数部分舍去，只保留整数部分。所以，将一个小数与<code>0</code>进行二进制或运算，等同于<strong>对该数去除小数部分，即取整数位</strong>。</p>
<p>二进制与运算符（<code>&amp;</code>）的规则是逐位比较两个运算子，两个二进制位之中只要有一个位为<code>0</code>，就返回<code>0</code>，否则返回<code>1</code>；</p>
<p>二进制否运算符（<code>~</code>）将每个二进制位都变为相反值（<code>0</code>变为<code>1</code>，<code>1</code>变为<code>0</code>）。它的返回结果有时比较难理解，因为涉及到计算机内部的数值表示机制。</p>
<p>因为涉及到反码，简单可以记忆为，一个数取否，等于 -1 减这个数；</p>
<p>对一个小数连续进行两次二进制否运算，能达到取整效果，而且是<strong>所有取整中最快的</strong>；</p>
<p>其他类型的值取否，会先调用<code>Number</code>函数，将字符串转为数值</p>
<p>“异或运算”有一个特殊运用，连续对两个数<code>a</code>和<code>b</code>进行三次异或运算，<code>a^=b; b^=a; a^=b;</code>，可以<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/XOR_swap_algorithm">互换</a>它们的值，这是互换两个变量的值的最快方法</p>
<p>如果左移0位，就相当于将该数值转为32位整数，等同于取整，对于正数和负数都有效；</p>
<p>头部补零的右移运算符（<code>&gt;&gt;&gt;</code>）头部一律补零，而对于正数，该运算的结果与右移运算符（<code>&gt;&gt;</code>）完全一致，区别主要在于负数。</p>
<p>查看一个负整数在计算机内部的储存形式，最快的方法就是使用这个运算符。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-<span class="number">1</span> &gt;&gt;&gt; <span class="number">0</span> <span class="comment">// 4294967295</span></span><br></pre></td></tr></table></figure>

<p>上面代码表示，<code>-1</code>作为32位整数时，内部的储存形式使用无符号整数格式解读，值为 4294967295（即<code>(2^32)-1</code>，等于<code>11111111111111111111111111111111</code>）。</p>
<h3 id="4-特殊运算符"><a href="#4-特殊运算符" class="headerlink" title="4. 特殊运算符"></a>4. 特殊运算符</h3><p><code>void</code>运算符的作用是执行一个表达式，然后不返回任何值，或者说返回<code>undefined</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="number">0</span> <span class="comment">// undefined</span></span><br><span class="line"><span class="title function_">void</span>(<span class="number">0</span>) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p>上面是<code>void</code>运算符的两种写法，都正确，第二种比较稳妥，因为 <code>void</code>优先级高，容易出错：</p>
<p>这个运算符的主要用途是浏览器的书签工具（Bookmarklet），以及在超级链接中插入代码防止网页跳转。</p>
<p>逗号运算符用于对两个表达式求值，并返回后一个表达式的值，逗号运算符的一个用途是，在返回一个值之前，进行一些辅助操作。</p>
<p>圆括号（<code>()</code>）可以用来提高运算的优先级，因为<strong>它的优先级是最高的</strong>，即圆括号中的表达式会第一个运算。</p>
<p>注意，因为圆括号不是运算符，所以不具有求值作用，只改变运算的优先级。</p>
<p>JavaScript 语言的大多数运算符是“左结合”，少数运算符是“右结合”，其中最主要的是<strong>赋值运算符（<code>=</code>）和三元条件运算符（<code>?:</code>）。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">w = x = y = z;</span><br><span class="line">q = a ? b : c ? d : e ? f : g;</span><br></pre></td></tr></table></figure>

<p>上面代码的解释方式如下。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">w = (x = (y = z));</span><br><span class="line">q = a ? b : (c ? d : (e ? f : g));</span><br></pre></td></tr></table></figure>

<p>上面的两行代码，都是右侧的运算数结合在一起。</p>
<p>另外，指数运算符（<code>**</code>）也是右结合。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span> ** <span class="number">3</span> ** <span class="number">2</span></span><br><span class="line"><span class="comment">// 相当于 2 ** (3 ** 2)</span></span><br><span class="line"><span class="comment">// 512</span></span><br></pre></td></tr></table></figure>

<h2 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h2><h3 id="1-强制转换"><a href="#1-强制转换" class="headerlink" title="1. 强制转换"></a>1. 强制转换</h3><p>只要有一个字符无法转成数值，整个字符串就会被转为<code>NaN</code>，而<code>parseInt</code>逐个解析字符；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Number</span>(<span class="string">&#x27;324abc&#x27;</span>) <span class="comment">// NaN</span></span><br><span class="line"><span class="title class_">Number</span>(<span class="string">&#x27;&#x27;</span>) <span class="comment">// 0</span></span><br><span class="line"><span class="title class_">Number</span>(<span class="literal">true</span>) <span class="comment">// 1</span></span><br><span class="line"><span class="title class_">Number</span>(<span class="literal">false</span>) <span class="comment">// 0</span></span><br><span class="line"><span class="title class_">Number</span>(<span class="literal">undefined</span>) <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>

<p><code>Number()</code>方法的参数是对象时，将返回<code>NaN</code>，除非是包含单个数值的数组；</p>
<p><code>String</code>函数可以将任意类型的值转化成字符串：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">String</span>(<span class="number">123</span>) <span class="comment">// &quot;123&quot;</span></span><br><span class="line"><span class="title class_">String</span>(<span class="string">&#x27;abc&#x27;</span>) <span class="comment">// &quot;abc&quot;</span></span><br><span class="line"><span class="title class_">String</span>(<span class="literal">true</span>) <span class="comment">// &quot;true&quot;</span></span><br><span class="line"><span class="title class_">String</span>(<span class="literal">undefined</span>) <span class="comment">// &quot;undefined&quot;</span></span><br><span class="line"><span class="title class_">String</span>(<span class="literal">null</span>) <span class="comment">// &quot;null</span></span><br></pre></td></tr></table></figure>

<p><code>String()</code>方法的参数如果是对象，返回一个类型字符串；如果是数组，返回该数组的字符串形式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">String</span>(&#123;<span class="attr">a</span>: <span class="number">1</span>&#125;) <span class="comment">// &quot;[object Object]&quot;</span></span><br><span class="line"><span class="title class_">String</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) <span class="comment">// &quot;1,2,3&quot;</span></span><br></pre></td></tr></table></figure>

<p><code>Boolean()</code>函数可以将任意类型的值转为布尔值：</p>
<p>除了以下五个值的转换结果为<code>false</code>，其他的值全部为<code>true</code>。</p>
<ul>
<li><code>undefined</code></li>
<li><code>null</code></li>
<li><code>0</code>（包含<code>-0</code>和<code>+0</code>）</li>
<li><code>NaN</code></li>
<li><code>&#39;&#39;</code>（空字符串）</li>
</ul>
<p>所有对象（包括空对象）的转换结果都是<code>true</code>，甚至连<code>false</code>对应的布尔对象<code>new Boolean(false)</code>也是<code>true</code>；</p>
<h3 id="2-自动转换"><a href="#2-自动转换" class="headerlink" title="2. 自动转换"></a>2. 自动转换</h3><ul>
<li>不同类型的数据互相运算；</li>
<li>对非布尔值类型的数据求布尔值；</li>
<li>对非数值类型的值使用一元运算符（即<code>+</code>和<code>-</code>）</li>
</ul>
<p>自动转换的规则是这样的：预期什么类型的值，就调用该类型的转换函数。比如，某个位置预期为字符串，就调用<code>String()</code>函数进行转换。如果该位置既可以是字符串，也可能是数值，那么默认转为数值。</p>
<h2 id="错误处理机制"><a href="#错误处理机制" class="headerlink" title="错误处理机制"></a>错误处理机制</h2><p><code>Error</code>构造函数，所有抛出的错误都是这个构造函数的实例：</p>
<ul>
<li><strong>message</strong>：错误提示信息</li>
<li><strong>name</strong>：错误名称（非标准属性）</li>
<li><strong>stack</strong>：错误的堆栈（非标准属性）</li>
</ul>
<p><code>Error</code>的6个派生对象：</p>
<ul>
<li><code>SyntaxError</code>解析代码时发生的语法错误；</li>
<li><code>ReferenceError</code>引用一个不存在的变量时发生的错误；</li>
<li><code>RangeError</code>一个值超出有效范围时发生的错误；</li>
<li><code>TypeError</code>对象是变量或参数不是预期类型时发生的错误；</li>
<li><code>URIError</code>对象是 URI 相关函数的参数不正确时抛出的错误，主要涉及<code>encodeURI()</code>、<code>decodeURI()</code>、<code>encodeURIComponent()</code>、<code>decodeURIComponent()</code>、<code>escape()</code>和<code>unescape()</code>这六个函数；</li>
<li><code>eval</code>函数没有被正确执行时，会抛出<code>EvalError</code>错误。该错误类型已经不再使用了；</li>
</ul>
<h3 id="1-自定义错误"><a href="#1-自定义错误" class="headerlink" title="1. 自定义错误"></a>1. 自定义错误</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">UserError</span>(<span class="params">message</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">message</span> = message || <span class="string">&#x27;默认信息&#x27;</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;UserError&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">UserError</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Error</span>();</span><br><span class="line"><span class="title class_">UserError</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">UserError</span>;</span><br></pre></td></tr></table></figure>

<p>上面代码自定义一个错误对象<code>UserError</code>，让它继承<code>Error</code>对象；</p>
<h3 id="2-处理错误语法"><a href="#2-处理错误语法" class="headerlink" title="2. 处理错误语法"></a>2. 处理错误语法</h3><p><code>throw</code>语句的作用是手动<strong>中断程序执行</strong>，抛出一个错误，实际上，可以抛出任何类型的值；</p>
<p>JavaScript 提供了<code>try...catch</code>结构，允许对错误进行处理，<strong>选择是否往下执行</strong>；</p>
<p><code>try</code>代码块抛出的错误，被<code>catch</code>代码块捕获后，程序会继续向下执行；</p>
<p><code>catch</code>代码块之中，还可以再抛出错误，甚至使用嵌套的<code>try...catch</code>结构；</p>
<p>为了捕捉不同类型的错误，<code>catch</code>代码块之中可以加入判断语句；</p>
<p><code>try...catch</code>结构允许在最后添加一个<code>finally</code>代码块，表示不管是否出现错误，都必需在最后运行的语句；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">throw</span> <span class="string">&#x27;bug&#x27;</span>;</span><br><span class="line">  &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 这句原本会延迟到 finally 代码块结束再执行</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>); <span class="comment">// 不会运行</span></span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 这句会覆盖掉前面那句 return</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>); <span class="comment">// 不会运行</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">5</span>); <span class="comment">// 不会运行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result = <span class="title function_">f</span>();</span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">result</span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p><code>catch</code>代码块之中，触发转入<code>finally</code>代码块的标志，不仅有<code>return</code>语句，还有<code>throw</code>语句；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="string">&#x27;出错了！&#x27;</span>;</span><br><span class="line">  &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;捕捉到内部错误&#x27;</span>);</span><br><span class="line">    <span class="keyword">throw</span> e; <span class="comment">// 这句原本会等到finally结束再执行</span></span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 直接返回</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="title function_">f</span>();</span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">  <span class="comment">// 此处不会执行</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;caught outer &quot;bogus&quot;&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  捕捉到内部错误</span></span><br></pre></td></tr></table></figure>

<p>面代码中，进入<code>catch</code>代码块之后，一遇到<code>throw</code>语句，就会去执行<code>finally</code>代码块，其中有<code>return false</code>语句，因此就直接返回了，不再会回去执行<code>catch</code>代码块剩下的部分了。</p>
<h2 id="代码风格"><a href="#代码风格" class="headerlink" title="代码风格"></a>代码风格</h2><ul>
<li><p>始终坚持一种选择。不要一会使用 Tab 键，一会使用空格键，进行缩进；</p>
</li>
<li><p>建议总是使用大括号表示区块，表示区块起首的大括号，不要另起一行</p>
</li>
<li><p>用空区分函数调用和表达式：</p>
<ul>
<li>表示函数调用时，函数名与左括号之间没有空格；</li>
<li>表示函数定义时，函数名与左括号之间没有空格；</li>
<li>其他情况时，前面位置的语法元素与左括号之间，都有一个空格；</li>
</ul>
</li>
<li><p>由于解释引擎自动添加分号的行为难以预测，因此编写代码的时候不应该省略行尾的分号；</p>
</li>
<li><p>不写结尾的分号，可能会导致脚本合并出错。所以，有的代码库在第一行语句开始前，会加上一个分号；</p>
</li>
<li><p>JavaScript 最大的语法缺点，可能就是全局变量对于任何一个代码块，都是可读可写。这对代码的模块化和重复使用，非常不利。因此，建议<strong>避免使用全局变量</strong>，可以考虑用大写字母表示变量名；</p>
</li>
<li><p>变量声明都放在代码块的头部，所有函数都应该在使用之前定义。函数内部的变量声明，都应该放在函数的头部；</p>
</li>
<li><p>不要使用<code>with</code>语句，会造成混淆；</p>
</li>
<li><p>建议不要使用相等运算符（<code>==</code>），只使用严格相等运算符（<code>===</code>）；</p>
</li>
<li><p>建议不要将不同目的的语句，合并成一行；</p>
</li>
<li><p>建议自增（<code>++</code>）和自减（<code>--</code>）运算符尽量使用<code>+=</code>和<code>-=</code>代替；</p>
</li>
<li><p>建议<code>switch...case</code>结构可以用对象结构代替：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">doAction</span>(<span class="params">action</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> actions = &#123;</span><br><span class="line">    <span class="string">&#x27;hack&#x27;</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&#x27;hack&#x27;</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&#x27;slash&#x27;</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&#x27;slash&#x27;</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&#x27;run&#x27;</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&#x27;run&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> actions[action] !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Invalid action.&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> actions[action]();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="console-对象与控制台"><a href="#console-对象与控制台" class="headerlink" title="console 对象与控制台"></a>console 对象与控制台</h2><p>开发者工具以后，顶端有多个面板：</p>
<ul>
<li><strong>Elements</strong>：查看网页的 HTML 源码和 CSS 代码。</li>
<li><strong>Resources</strong>：查看网页加载的各种资源文件（比如代码文件、字体文件 CSS 文件等），以及在硬盘上创建的各种内容（比如本地缓存、Cookie、Local Storage等）。</li>
<li><strong>Network</strong>：查看网页的 HTTP 通信情况。</li>
<li><strong>Sources</strong>：查看网页加载的脚本源码。</li>
<li><strong>Timeline</strong>：查看各种网页行为随时间变化的情况。</li>
<li><strong>Performance</strong>：查看网页的性能情况，比如 CPU 和内存消耗。</li>
<li><strong>Console</strong>：用来运行 JavaScript 命令</li>
</ul>
<h3 id="1-log-info-debug"><a href="#1-log-info-debug" class="headerlink" title="1. log, info, debug"></a>1. log, info, debug</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27; %s + %s = %s&#x27;</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(&#123;<span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span>&#125;)</span><br><span class="line"><span class="comment">// Object &#123;foo: &quot;bar&quot;&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Date</span>)</span><br><span class="line"><span class="comment">// function Date() &#123; [native code] &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(</span><br><span class="line">  <span class="string">&#x27;%cThis text is styled!&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;color: red; background: yellow; font-size: 24px;&#x27;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>%o</code> 对象的链接</li>
<li><code>%c</code> CSS 格式字符串</li>
</ul>
<p><code>console.info</code>是<code>console.log</code>方法的别名，用法完全一样。只不过<code>console.info</code>方法会在输出信息的前面，加上一个蓝色图标；</p>
<p><code>console.debug</code>方法与<code>console.log</code>方法类似，会在控制台输出调试信息。但是，默认情况下，<code>console.debug</code>输出的信息不会显示，只有在打开显示级别在<code>verbose</code>的情况下，才会显示；</p>
<p><code>console</code>对象的所有方法，都可以被覆盖。因此，可以按照自己的需要，定义<code>console.log</code>方法</p>
<h3 id="2-warn-error"><a href="#2-warn-error" class="headerlink" title="2. warn, error"></a>2. warn, error</h3><p><code>warn</code>方法和<code>error</code>方法也是在控制台输出信息，它们与<code>log</code>方法的不同之处在于，<code>warn</code>方法输出信息时，在最前面加一个黄色三角，表示警告；</p>
<p><code>error</code>方法输出信息时，在最前面加一个红色的叉，表示出错。同时，还会高亮显示输出文字和错误发生的堆栈。其他方面都一样；</p>
<h3 id="3-table"><a href="#3-table" class="headerlink" title="3. table"></a>3. table</h3><p>对于某些复合类型的数据，<code>console.table</code>方法可以将其转为表格显示；</p>
<h3 id="4-count"><a href="#4-count" class="headerlink" title="4. count"></a>4. count</h3><p><code>count</code>方法用于计数，输出它被调用了多少次，可以接受一个字符串作为参数，作为标签，对执行次数进行分类；</p>
<h3 id="5-dir-dirxml"><a href="#5-dir-dirxml" class="headerlink" title="5. dir, dirxml"></a>5. dir, dirxml</h3><p><code>dir</code>方法用来对一个对象进行检查（inspect），并以易于阅读和打印的格式显示，对于输出 DOM 对象非常有用，因为会显示 DOM 对象的所有属性；</p>
<p><code>dirxml</code>方法主要用于以目录树的形式，显示 DOM 节点，如果参数不是 DOM 节点，而是普通的 JavaScript 对象，则等价于<code>dir</code>；</p>
<h3 id="6-assert"><a href="#6-assert" class="headerlink" title="6. assert"></a>6. assert</h3><p><code>console.assert</code>方法主要用于程序运行过程中，进行条件判断，如果不满足条件，就显示一个错误，但不会中断程序执行。这样就相当于提示用户，内部状态不正确。</p>
<p>接受两个参数，第一个参数是表达式，第二个参数是字符串。当第一个参数为<code>false</code>，才会提示有错误，在控制台输出第二个参数，否则不会有任何结果。</p>
<h3 id="7-time-timeEnd"><a href="#7-time-timeEnd" class="headerlink" title="7. time, timeEnd"></a>7. time, timeEnd</h3><p>这两个方法用于计时，可以算出一个操作所花费的准确时间，它们的参数是计时器的名称；</p>
<h3 id="8-group-groupEnd-groupCollapse"><a href="#8-group-groupEnd-groupCollapse" class="headerlink" title="8. group, groupEnd, groupCollapse"></a>8. group, groupEnd, groupCollapse</h3><p><code>console.group</code>和<code>console.groupEnd</code>这两个方法用于<strong>将显示的信息分组</strong>。它只在输出大量信息时有用，分在一组的信息，可以用鼠标折叠&#x2F;展开；</p>
<p><code>console.groupCollapsed</code>方法与<code>console.group</code>方法很类似，唯一的区别是该组的内容，在第一次显示时是收起的（collapsed），而不是展开的；</p>
<h3 id="9-trace-clear"><a href="#9-trace-clear" class="headerlink" title="9. trace, clear"></a>9. trace, clear</h3><p><code>console.trace</code>方法显示当前执行的代码在堆栈中的调用路径；</p>
<p><code>console.clear</code>方法用于清除当前控制台的所有输出；</p>
<h3 id="10-控制台命令行-API"><a href="#10-控制台命令行-API" class="headerlink" title="10. 控制台命令行 API"></a>10. 控制台命令行 API</h3><ul>
<li><code>$_</code>属性返回上一个表达式的值，<code>\$0</code>- <code>\$4</code> 分别代表了最近五个 Elements 面板中选中的元素；</li>
<li><code>$(selector)</code>返回第一个匹配的元素，<code>$$(selector)</code>返回选中的DOM对象；</li>
<li><code>$x(path)</code>方法返回一个数组，包含匹配特定 XPath 表达式的所有 DOM 元素；</li>
<li><code>inspect(object)</code>方法打开相关面板，并选中相应的元素，显示它的细节；</li>
<li><code>getEventListeners(object)</code>方法返回一个对象，该对象的成员为<code>object</code>登记了回调函数的各种事件（比如<code>click</code>或<code>keydown</code>），每个事件对应一个数组，数组的成员为该事件的回调函数；</li>
<li><code>monitorEvents(object[, events])</code>方法监听特定对象上发生的特定事件。事件发生时，会返回一个<code>Event</code>对象，包含该事件的相关信息。<code>unmonitorEvents</code>方法用于停止监听；</li>
</ul>
<h3 id="11-debugger"><a href="#11-debugger" class="headerlink" title="11. debugger"></a>11. debugger</h3><p><code>debugger</code>语句主要用于除错，作用是设置断点。如果有正在运行的除错工具，程序运行到<code>debugger</code>语句时会自动停下。如果没有除错工具，<code>debugger</code>语句不会产生任何结果，JavaScript 引擎自动跳过这一句。</p>
<p>Chrome 浏览器中，当代码运行到<code>debugger</code>语句时，就会暂停运行，自动打开脚本源码界面。</p>
</article><div id="paginator"></div></main><footer><div class="icon-wrapper in-left"><button class="icon-button" aria-label="change theme"><span class="icon"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" height="100%" width="100%"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z"></path></svg></span></button></div><div class="icon-wrapper in-right"><button class="icon-button" aria-label="change theme"><span class="icon"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" height="100%" width="100%"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 15l7-7 7 7"></path></svg></span></button></div><p class="copyright-text"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noreferrer">CC BY-NC-SA 4.0</a><span>·</span><a href="https://github.com/ttttonyhe/ouorz-mono" target="_blank" rel="noreferrer">Open Source Software (OSS)</a></p></footer><script src="/js/ouo.js"></script></div></body></html>