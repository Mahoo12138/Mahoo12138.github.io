<!DOCTYPE html>
<html lang="en" color-mode="light">

  <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="keywords" content="" />
  <meta name="author" content="Mahoo12138" />
  <meta name="description" content="" />
  
  
  <title>
    
      Kotlin 语言基础学习 
      
      
      |
    
     Mahoo12138
  </title>

  
    <link rel="apple-touch-icon" href="/images/favicon.png">
    <link rel="icon" href="/images/favicon.png">
  

  <!-- Raleway-Font -->
  <link href="https://fonts.googleapis.com/css?family=Raleway&display=swap" rel="stylesheet">

  <!-- hexo site css -->
  <link rel="stylesheet" href="/css/main.css" />
  <link rel="stylesheet" href="//at.alicdn.com/t/font_1886449_67xjft27j1l.css" />
  <!-- 代码块风格 -->
  

  <!-- jquery3.3.1 -->
  
    <script defer type="text/javascript" src="/plugins/jquery.min.js"></script>
  

  <!-- fancybox -->
  
    <link href="/plugins/jquery.fancybox.min.css" rel="stylesheet">
    <script defer type="text/javascript" src="/plugins/jquery.fancybox.min.js"></script>
  
  
<script src="/js/fancybox.js"></script>


  

  

  <script>
    var html = document.documentElement
    const colorMode = localStorage.getItem('color-mode')
    if (colorMode) {
      document.documentElement.setAttribute('color-mode', colorMode)
    }
  </script>
<meta name="generator" content="Hexo 7.2.0"></head>


  <body>
    <div id="app">
      <div class="header">
  <div class="avatar">
    <a href="/">
      <!-- 头像取消懒加载，添加no-lazy -->
      
        <img src="/images/avatar.png" alt="">
      
    </a>
    <div class="nickname"><a href="/">Mahoo12138</a></div>
  </div>
  <div class="navbar">
    <ul>
      
        <li class="nav-item" data-path="/">
          <a href="/">Home</a>
        </li>
      
        <li class="nav-item" data-path="/archives/">
          <a href="/archives/">Archives</a>
        </li>
      
        <li class="nav-item" data-path="/tags/">
          <a href="/tags/">Tags</a>
        </li>
      
        <li class="nav-item" data-path="/friends/">
          <a href="/friends/">Friends</a>
        </li>
      
        <li class="nav-item" data-path="/about/">
          <a href="/about/">About</a>
        </li>
      
    </ul>
  </div>
</div>


<script src="/js/activeNav.js"></script>



      <div class="flex-container">
        <!-- 文章详情页，展示文章具体内容，url形式：https://yoursite/文章标题/ -->
<!-- 同时为「标签tag」，「朋友friend」，「分类categories」，「关于about」页面的承载页面，具体展示取决于page.type -->


  <!-- LaTex Display -->

  
    <script async type="text/javascript" src="/plugins/mathjax/tex-chtml.js"></script>
  
  <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']]
      }
    }
  </script>





  <!-- clipboard -->

  
    <script async type="text/javascript" src="/plugins/clipboard.min.js"></script>
  
  
<script src="/js/codeCopy.js"></script>







  

  

  

  
  <!-- 文章内容页 url形式：https://yoursite/文章标题/ -->
  <div class="container post-details" id="post-details">
    <div class="post-content">
      <div class="post-title">Kotlin 语言基础学习</div>
      <div class="post-attach">
        <span class="post-pubtime">
          <i class="iconfont icon-updatetime mr-10" title="Update time"></i>
          2019-07-14 23:01:25
        </span>
        
              <span class="post-tags">
                <i class="iconfont icon-tags mr-10" title="Tags"></i>
                
                <span class="span--tag mr-8">
                  <a href="/tags/Kotlin/" title="Kotlin">
                    #Kotlin
                  </a>
                </span>
                
              </span>
          
      </div>
      <div class="markdown-body">
        <h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><h2 id="定义包"><a href="#定义包" class="headerlink" title="定义包"></a>定义包</h2><p>包的声明应处于源文件顶部：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> my.demo</span><br><span class="line"><span class="keyword">import</span> java.util.*</span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure>

<p>目录与包的结构无需匹配：源代码可以放在文件系统的任意位置。</p>
<h2 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h2><p>带有两个<code>Int</code>参数，返回<code>Int</code>函数：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">sum</span> <span class="params">(a:<span class="type">Int</span>,b:<span class="type">Int</span>)</span></span>:<span class="built_in">Int</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>将表达式作为函数体，返回值类型自动推送的函数：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">sum</span> <span class="params">(a:<span class="type">Int</span>,b:<span class="type">Int</span>)</span></span> = a + b</span><br></pre></td></tr></table></figure>

<p>函数返回无意义的值：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">printSum</span><span class="params">(a:<span class="type">Int</span>,b:<span class="type">Int</span>)</span></span>&#123;</span><br><span class="line">	println(<span class="string">&quot;sum <span class="variable">$a</span> and <span class="variable">$b</span> is <span class="subst">$&#123;a+b&#125;</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Unit</code>返回类型可以省略：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">printSum</span><span class="params">(a:<span class="type">Int</span>,b:<span class="type">Int</span>)</span></span>&#123;</span><br><span class="line">    println(<span class="string">&quot;sum of <span class="variable">$a</span> and <span class="variable">$b</span> is <span class="subst">$&#123;a+b&#125;</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="定义变量"><a href="#定义变量" class="headerlink" title="定义变量"></a>定义变量</h2><p>定义<strong>只读局部变量</strong>使用关键字<code>val</code>定义。只能为其赋值一次。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> a:<span class="built_in">Int</span> = <span class="number">1</span>	<span class="comment">//立即赋值</span></span><br><span class="line"><span class="keyword">val</span> b = <span class="number">2</span>		<span class="comment">//自动推出‘Int’类型</span></span><br><span class="line"><span class="keyword">val</span> c:<span class="built_in">Int</span>		<span class="comment">//如果没有赋初值，则不能省略</span></span><br><span class="line">c = <span class="number">2</span>			<span class="comment">//明确赋值</span></span><br></pre></td></tr></table></figure>

<p>可重新赋值的变量使用<code>var</code>关键字：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">5</span></span><br><span class="line">x += <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>顶层变量：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> PI = <span class="number">3.14</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">0</span></span><br></pre></td></tr></table></figure>

<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>正如Java，Kotlin支持行注释及块注释。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是一个行注释</span></span><br><span class="line"><span class="comment">/* 这是一个多行的</span></span><br><span class="line"><span class="comment">   块注释。*/</span></span><br></pre></td></tr></table></figure>

<p>与Java不同的是，Kotlin的块注释可以嵌套。</p>
<h2 id="使用字符串模板"><a href="#使用字符串模板" class="headerlink" title="使用字符串模板"></a>使用字符串模板</h2><p>使用字符串模板的符号为（<code>$</code>）。在<code>$</code>符号后面加上变量名或大括号中的表达式</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> s1 = <span class="string">&quot;a is <span class="variable">$a</span>&quot;</span></span><br><span class="line"><span class="comment">// 模板中的简单名称</span></span><br><span class="line"></span><br><span class="line">a = <span class="number">2</span></span><br><span class="line"><span class="keyword">val</span> s2 = <span class="string">&quot;<span class="subst">$&#123;s1.replace(<span class="string">&quot;is&quot;</span>,<span class="string">&quot;was&quot;</span>)&#125;</span>,but now is <span class="variable">$a</span>&quot;</span></span><br><span class="line"><span class="comment">//模板中的任意表达式</span></span><br><span class="line"></span><br><span class="line">println(s2)</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a was 1, but now is 2</span><br></pre></td></tr></table></figure>
<h2 id="声明可空变量"><a href="#声明可空变量" class="headerlink" title="声明可空变量"></a>声明可空变量</h2><p>在Kotlin中当我们不确定某个属性或变量一定不为空时，我们就把它声明为<strong>可空变量</strong>.</p>
<p>可空变量的特点：</p>
<ul>
<li>在声明的时候一定要用标准的声明格式定义。不能用可推断类型的简写；</li>
<li>变量类型后面的<code>?</code>符号不能省略。不然就和普通的变量没区别了；</li>
<li>其初始化的值可以为<code>null</code>或确定的变量值。</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="comment">//声明可空变量</span></span><br><span class="line">    <span class="keyword">var</span> a:<span class="built_in">Int</span>? = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">val</span> b:<span class="built_in">Int</span>? = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="常量的用法"><a href="#常量的用法" class="headerlink" title="常量的用法"></a>常量的用法</h2><p>在Kotlin中<code>val</code>修饰的还不是常量，他只是个不能修改的变量。常量的定义还需要再<code>val</code>关键字前加上<code>const</code>关键字。即：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">val</span> NUM_A = <span class="number">6</span></span><br></pre></td></tr></table></figure>

<p>其特点：**<code>const</code>只能修饰<code>val</code>，不能修饰<code>var</code>**。</p>
<p>声明常量的三种方式：</p>
<ol>
<li>在顶层声明；</li>
<li>在<code>object</code>修饰的类中声明，在<code>kotlin</code>中称为<strong>对象声明</strong>；</li>
<li>在伴生对象中声明。</li>
</ol>
<p>例如：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.顶层声明</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">val</span> Str_A :String = <span class="string">&quot;顶层声明&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.在object修饰的类中</span></span><br><span class="line"><span class="keyword">object</span> TestConst&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">val</span> Str_B = <span class="string">&quot;object修饰的类中&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 3.在伴生对象中</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestClass</span>&#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">val</span> Str_C = <span class="string">&quot;在伴生对象中&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><h2 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h2><h3 id="1-数字的内置类型"><a href="#1-数字的内置类型" class="headerlink" title="1. 数字的内置类型"></a>1. 数字的内置类型</h3><ul>
<li><code>Byte </code> &#x3D;&gt; 字节 &#x3D;&gt; 8位</li>
<li><code>Short</code> &#x3D;&gt; 短整型 &#x3D;&gt; 16位</li>
<li><code>Int</code> &#x3D;&gt; 整型 &#x3D;&gt; 32位</li>
<li><code>Long</code> &#x3D;&gt; 长整型 &#x3D;&gt; 64位</li>
<li><code>Float</code> &#x3D;&gt; 浮点型 &#x3D;&gt; 32位</li>
<li><code>Double</code> &#x3D;&gt; 双精度浮点型 &#x3D;&gt; 64位</li>
</ul>
<p>注意：</p>
<ul>
<li>长整型在数值末用大写字母L标记</li>
<li>单精度浮点型由字母F（大写小写无妨）标记</li>
</ul>
<h3 id="2-进制数"><a href="#2-进制数" class="headerlink" title="2. 进制数"></a>2. 进制数</h3><p>Kotlin不支持八进制数</p>
<h3 id="3-数字类型字面常量的下划线"><a href="#3-数字类型字面常量的下划线" class="headerlink" title="3. 数字类型字面常量的下划线"></a>3. 数字类型字面常量的下划线</h3><p>作用：<strong>分割数字进行分组，使数字常量更易读</strong></p>
<p>例如：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> oneMillion = <span class="number">1_000_000</span></span><br><span class="line"><span class="keyword">val</span> phoneNum = <span class="number">155_0746_2014</span></span><br></pre></td></tr></table></figure>

<h3 id="4-装箱与拆箱"><a href="#4-装箱与拆箱" class="headerlink" title="4. 装箱与拆箱"></a>4. 装箱与拆箱</h3><p>装箱就是值类型转换为object类型，拆箱相反：object转化为值类型。在<code>kotlin</code>中，存在数字的装箱，但是没有拆箱。因为<code>kotlin</code>是没有基本数据类型的，<code>Kotlin</code>是万物皆对象的原则。</p>
<p>在<code>kotlin</code>中要实现装箱操作，首先要了解可空引用。即类似<code>Int?</code>(只限数值类型)此类的：</p>
 <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> numValue:<span class="built_in">Int</span> = <span class="number">1</span></span><br><span class="line"><span class="comment">// 装箱的过程，装箱后其值是没有变化的</span></span><br><span class="line"><span class="keyword">val</span> numValueBox:<span class="built_in">Int</span> = numValue</span><br></pre></td></tr></table></figure>

<h4 id="两个数值的比较"><a href="#两个数值的比较" class="headerlink" title="两个数值的比较"></a>两个数值的比较</h4><ul>
<li>判断两个数值是否相等<code>==</code></li>
<li>判断两个数值在内存中的地址是否相等<code>===</code></li>
</ul>
<h3 id="5-转换"><a href="#5-转换" class="headerlink" title="5. 转换"></a>5. 转换</h3><ul>
<li><p>显式转换</p>
<p>较小的类型不会被隐式转换位更大的类型，故而系统提供了显式转换：</p>
<ul>
<li><code>toByte()</code> &#x3D;&gt; 转换为字节型</li>
<li><code>toShort()</code> &#x3D;&gt; 转换为短整型</li>
<li><code>toInt()</code> &#x3D;&gt; 转换为整型</li>
<li><code>toLong()</code> &#x3D;&gt; 转换为长整型</li>
<li><code>toFloat()</code> &#x3D;&gt; 转换为浮点型</li>
<li><code>toDouble()</code> &#x3D;&gt; 转换为双精度浮点型</li>
<li><code>toChar()</code> &#x3D;&gt; 转换为字符型</li>
<li><code>toString()</code> &#x3D;&gt; 转换为字符串型</li>
</ul>
</li>
<li><p>隐式转换</p>
<p>类型是从上下文推断出来的，即算术运算则被重载为适当的转换：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> num = <span class="number">30L</span> + <span class="number">12</span></span><br><span class="line">println(num)</span><br><span class="line"><span class="comment">// 30L + 12 -&gt; Long + Int =&gt; Long</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="6-位运算符"><a href="#6-位运算符" class="headerlink" title="6. 位运算符"></a>6. 位运算符</h3><p>&#x2F;&#x2F; 。。。。。</p>
<h2 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h2><h3 id="1-关键字"><a href="#1-关键字" class="headerlink" title="1. 关键字"></a>1. 关键字</h3><p><code>Boolean</code>关键字表示布尔类型，并且其值有<code>ture</code>和<code>false</code></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isNum:<span class="built_in">Boolean</span></span><br><span class="line">isNum = <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<h3 id="2-逻辑操作符"><a href="#2-逻辑操作符" class="headerlink" title="2. 逻辑操作符"></a>2. 逻辑操作符</h3><ul>
<li>‘||’ &#x3D;&gt; 逻辑或</li>
<li>‘&amp;&amp;’ &#x3D;&gt; 逻辑与</li>
<li>‘ ! ’ &#x3D;&gt; 逻辑非</li>
</ul>
<h2 id="字符型"><a href="#字符型" class="headerlink" title="字符型"></a>字符型</h2><h3 id="1-关键字-1"><a href="#1-关键字-1" class="headerlink" title="1. 关键字"></a>1. 关键字</h3><p><code>Char</code>表示字符型，字符变量用单引号(‘’)表示。并且不能直接视为数字，不过可以通过显式转换为数字：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> char_1:<span class="built_in">Char</span></span><br><span class="line">char = <span class="string">&#x27;a&#x27;</span></span><br><span class="line">char = <span class="number">1</span>	<span class="comment">//报错</span></span><br></pre></td></tr></table></figure>

<h3 id="2-显示转换为其他类型"><a href="#2-显示转换为其他类型" class="headerlink" title="2. 显示转换为其他类型"></a>2. 显示转换为其他类型</h3><p>字符型的变量不仅会可以转换为数字，同时也可转换为其他类型：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> var1 = char_1.toByte()</span><br><span class="line"><span class="keyword">var</span> var2 = char_1.toInt()</span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure>

<p>除了类型转换，当变量为英文字母时还支持大小写转换：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> charA:<span class="built_in">Char</span> = <span class="string">&#x27;a&#x27;</span></span><br><span class="line"><span class="keyword">var</span> charB:<span class="built_in">Char</span> = <span class="string">&#x27;B&#x27;</span></span><br><span class="line"><span class="keyword">var</span> result:<span class="built_in">Char</span></span><br><span class="line"></span><br><span class="line">result = charA.toUpperCase()	<span class="comment">//转换为大写</span></span><br><span class="line">result = charB.toLowerCase()	<span class="comment">//转换为小写</span></span><br></pre></td></tr></table></figure>

<h3 id="3-字符转义"><a href="#3-字符转义" class="headerlink" title="3. 字符转义"></a>3. 字符转义</h3><ul>
<li><code>\t</code> &#x3D;&gt; 制表符</li>
<li><code>\n</code> &#x3D;&gt; 换行符</li>
<li><code>\b</code>&#x3D;&gt; 退格键</li>
<li><code>\r</code>&#x3D;&gt; 回车键</li>
<li><code>\\</code>&#x3D;&gt; 反斜杠</li>
<li><code>\&#39;</code>&#x3D;&gt; 单引号</li>
<li><code>\$</code> &#x3D;&gt; 美元符号</li>
<li>**其他的任何字符请使用Unicode转义序列语法，例如：’\uFF00’</li>
</ul>
<h2 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h2><h3 id="1-关键字-2"><a href="#1-关键字-2" class="headerlink" title="1. 关键字"></a>1. 关键字</h3><p><code>String</code>表示字符串类型。其实不可变的。所以字符串的元素可以通过索引操作的字符：<code>str[index]</code>来访问。可以使用<code>for</code>循环迭代字符串：其中<code>str[index]</code>中的<code>str</code>要为目标字符串，<code>index</code>才能为索引：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> str:Sting = <span class="string">&quot;kotlin&quot;</span></span><br><span class="line"><span class="comment">//迭代</span></span><br><span class="line"><span class="keyword">for</span> (s <span class="keyword">in</span> str)&#123;</span><br><span class="line">    print(s)</span><br><span class="line">    print(<span class="string">&quot;\t&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-字符串字面量"><a href="#2-字符串字面量" class="headerlink" title="2. 字符串字面量"></a>2. 字符串字面量</h3><p>在<code>Kotlin</code>中，字符串字面量有两种类型：</p>
<ul>
<li>包含转义字符的字符串，转义包括（\t, \n等），不包括转义字符串的也同属此类型</li>
<li>包含任意字符的字符串，有三重引号（<code>&quot;&quot;&quot;...&quot;&quot;&quot;</code>）表示</li>
</ul>
<h2 id="数组型"><a href="#数组型" class="headerlink" title="数组型"></a>数组型</h2><ul>
<li><code>Kotlin中</code>数组由<code>Array&lt;T&gt;表示</code></li>
<li>创建数组的三个函数：<ul>
<li><code>arrayOf()</code></li>
<li><code>arrayOfNulls()</code></li>
<li>工厂函数（<code>Array()</code>）</li>
</ul>
</li>
</ul>
<h3 id="1-arrayOf"><a href="#1-arrayOf" class="headerlink" title="1. arrayOf()"></a>1. arrayOf()</h3><p>创建一个数组，参数是一个可变参数的泛型对象：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> arr1 = arrayOf(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line"><span class="keyword">for</span> (v <span class="keyword">in</span> arr1)&#123;</span><br><span class="line">    print(v)</span><br><span class="line">    print(<span class="string">&quot;\t&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-arrayOfNulls"><a href="#2-arrayOfNulls" class="headerlink" title="2. arrayOfNulls()"></a>2. arrayOfNulls()</h3><p>用于创建一个指定数据类型且可以为空元素的，给定元素个数的数组：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr2 = arrayOfNulls&lt;<span class="built_in">Int</span>&gt;(<span class="number">3</span>)</span><br><span class="line"><span class="comment">// 若不予数组赋值则arr3内元素皆为null</span></span><br></pre></td></tr></table></figure>

<h3 id="3-工厂函数"><a href="#3-工厂函数" class="headerlink" title="3. 工厂函数"></a>3. 工厂函数</h3><ul>
<li>使用工厂函数<code>Array()</code>，它使用数组大小和返回给定其索引的每个数组元素的初始值的函数。</li>
<li><code>Array()</code>&#x3D;&gt; 第一个参数表示的个数，第二个参数则为使用其下标组成的表达式</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr3 = Array(<span class="number">5</span>,&#123;index -&gt; (index*<span class="number">2</span>).toString()&#125;)</span><br><span class="line"><span class="keyword">for</span> (v <span class="keyword">in</span> arr4)&#123;</span><br><span class="line">    print(v)</span><br><span class="line">    print(<span class="string">&quot;\t&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>	<span class="number">2</span>	<span class="number">4</span>	<span class="number">6</span>	<span class="number">8</span></span><br></pre></td></tr></table></figure>

<h3 id="4-原始类型数组"><a href="#4-原始类型数组" class="headerlink" title="4. 原始类型数组"></a>4. 原始类型数组</h3><p><code>kotlin</code>还有专门的类来表示原始类型的数组，没有装箱开销，它们分别是：</p>
<ul>
<li><code>ByteArray</code> &#x3D;&gt; 表示字节型数组</li>
<li><code>ShortArray</code> &#x3D;&gt; 表示短整型数组</li>
<li><code>IntArray</code> &#x3D;&gt; 表示整型数组</li>
<li><code>LongArray</code> &#x3D;&gt; 表示长整型数组</li>
<li><code>BooleanArray</code> &#x3D;&gt; 表示布尔型数组</li>
<li><code>CharArray</code> &#x3D;&gt; 表示字符型数组</li>
<li><code>FloatArray</code> &#x3D;&gt; 表示浮点型数组</li>
<li><code>DoubleArray</code> &#x3D;&gt; 表示双精度浮点型数组</li>
</ul>
<p><strong><code>Kotlin</code>不支持字符串类型这种原始类型的数组</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> intArr:IntArray = intArrayOf(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> charArr:CharArray = charArrayOf(<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;2&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h1 id="控制语句"><a href="#控制语句" class="headerlink" title="控制语句"></a>控制语句</h1><h2 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h2><p><code>kotlin</code>中的<code>if</code>语句很灵活，除了普通的判断，还可以实现表达式（实现三元运算符），及作为一个块的作用</p>
<h3 id="1-传统写法"><a href="#1-传统写法" class="headerlink" title="1. 传统写法"></a>1. 传统写法</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> numA = <span class="number">2</span></span><br><span class="line"><span class="keyword">if</span> (numA == <span class="number">2</span>)&#123;</span><br><span class="line">    println($numA)</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    println($numA-<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-Kotlin中的三元运算符"><a href="#2-Kotlin中的三元运算符" class="headerlink" title="2. Kotlin中的三元运算符"></a>2. <code>Kotlin</code>中的三元运算符</h3><p>在<code>Kotlin</code>中其实不存在三元运算符（<em>condition ？ then ： else</em>）这种运算，那是因为if语句的特性：<code>if</code>表达式会返回一个值，所以不需要三元运算符。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> numB:<span class="built_in">Int</span> = <span class="keyword">if</span> (numA &gt; <span class="number">2</span>) <span class="number">3</span> <span class="keyword">else</span> <span class="number">5</span></span><br><span class="line">println(numB)</span><br></pre></td></tr></table></figure>

<h3 id="3-作为一个块结构，并且最后一句表达式为块的值"><a href="#3-作为一个块结构，并且最后一句表达式为块的值" class="headerlink" title="3. 作为一个块结构，并且最后一句表达式为块的值"></a>3. 作为一个块结构，并且最后一句表达式为块的值</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> numA:<span class="built_in">Int</span> = <span class="number">2</span></span><br><span class="line"><span class="keyword">var</span> numC:<span class="built_in">Int</span> = <span class="keyword">if</span>(numA &gt; <span class="number">2</span>)&#123;</span><br><span class="line">    numA = <span class="number">10</span></span><br><span class="line">	numA</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> (numA == <span class="number">2</span>)&#123;</span><br><span class="line">    numA = <span class="number">20</span></span><br><span class="line">    numA</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    numA = <span class="number">30</span></span><br><span class="line">    numA</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="for语句"><a href="#for语句" class="headerlink" title="for语句"></a>for语句</h2><ul>
<li><code>for</code>循环提供迭代器用来遍历任何东西</li>
<li><code>for</code>循环数组被编译为一个基于索引的循环，它不会创建一个迭代器对象</li>
</ul>
<h3 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h3><ul>
<li><p>递增</p>
<ul>
<li><p>关键字：<code>until</code></p>
</li>
<li><p>范围：<code>until[n,m]</code> &#x3D;&gt; 大于等于n，小于m</p>
</li>
<li><p>例如：</p>
</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 循环5次，且步长为1的递增</span></span><br><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until <span class="number">5</span>)&#123;</span><br><span class="line">    print(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>递减</p>
<ul>
<li>关键字：<code>downTo</code></li>
</ul>
<ul>
<li><p>范围：<code>downTo[n,m]</code> &#x3D;&gt; 大于等于n，小于等于m，n &gt; m</p>
</li>
<li><p>例如：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 循环5次，且步长为1的递减</span></span><br><span class="line"><span class="keyword">for</span>(i <span class="keyword">in</span> <span class="number">15</span> downTo <span class="number">11</span>)&#123;</span><br><span class="line">    print(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>符号(<code>..</code>)</p>
<p>表示递增循环的另外一种操作</p>
<ul>
<li><p>使用符号<code>..</code></p>
</li>
<li><p>范围：<code>..[n,m]</code> &#x3D;&gt; 即<code>大于等于n,小于等于m</code></p>
</li>
<li><p>和<code>until</code>有区别，但更为简便，且范围不同</p>
</li>
<li><p>例如：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">20.</span><span class="number">.25</span>)&#123;</span><br><span class="line">    print(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>设置步长</p>
<ul>
<li><p>关键字：<code>step</code></p>
</li>
<li><p>例如：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">10</span> until <span class="number">16</span> step <span class="number">2</span>)&#123;</span><br><span class="line">    print(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="遍历字符串"><a href="#遍历字符串" class="headerlink" title="遍历字符串"></a>遍历字符串</h3><p>例如：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="string">&quot;asdfghjk&quot;</span>)&#123;</span><br><span class="line">    print(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="遍历数组"><a href="#遍历数组" class="headerlink" title="遍历数组"></a>遍历数组</h3><p>例如：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arrayList = arrayOf(<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>)</span><br><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> arrayList)&#123;</span><br><span class="line">    print(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arrayList = arrayOf(<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>)</span><br><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> arrayListTwo.indices)&#123;</span><br><span class="line">    println(<span class="string">&quot;arrayList[<span class="variable">$i</span>] =&gt; &quot;</span> + arrayList[i])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arrayList = arrayOf(<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>)</span><br><span class="line"><span class="keyword">for</span> ((index,value) <span class="keyword">in</span> arrayList.withIndex())&#123;</span><br><span class="line">    println(<span class="string">&quot;index =&gt; <span class="variable">$index</span> \t value =&gt; <span class="variable">$value</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="使用列表或数组的扩展函数遍历"><a href="#使用列表或数组的扩展函数遍历" class="headerlink" title="使用列表或数组的扩展函数遍历"></a>使用列表或数组的扩展函数遍历</h4><ul>
<li>数组或列表有一个成员或扩展函数<code>iterator()</code>实现了<code>Iterator&lt;T&gt;</code>接口，且该接口提供了<code>next()</code>与<code>hasNext()</code>两个成员或扩展函数</li>
<li>其一般和<code>while</code>循环一起使用</li>
</ul>
<p>例如：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arrayList = arrayOf(<span class="number">2</span>,<span class="string">&#x27;a&#x27;</span>,<span class="number">3</span>,<span class="literal">false</span>,<span class="number">9</span>)</span><br><span class="line"><span class="keyword">var</span> iterator: Iterator&lt;Any&gt; = arrayList.iterator()</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">    println(iterator.next())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="when语句"><a href="#when语句" class="headerlink" title="when语句"></a>when语句</h2><p><code>when</code>语句类似于C类语言中的<code>switch</code>语句，不过比它更强大。</p>
<h3 id="实现switch语句功能"><a href="#实现switch语句功能" class="headerlink" title="实现switch语句功能"></a>实现switch语句功能</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">when</span>(<span class="number">5</span>)&#123;</span><br><span class="line">    <span class="number">1</span> -&gt; &#123;</span><br><span class="line">        print(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="number">2</span> -&gt; &#123;</span><br><span class="line">        print(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    esle -&gt; &#123;</span><br><span class="line">        print(<span class="string">&quot;5&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="与逗号结合"><a href="#与逗号结合" class="headerlink" title="与逗号结合"></a>与逗号结合</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">when</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="comment">// 即值为1，2，3时都输出1</span></span><br><span class="line">    <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> -&gt; &#123;</span><br><span class="line">        print(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> -&gt; &#123;</span><br><span class="line">        print(<span class="string">&quot;0&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="条件可以使用任意表达式"><a href="#条件可以使用任意表达式" class="headerlink" title="条件可以使用任意表达式"></a>条件可以使用任意表达式</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num:<span class="built_in">Int</span> = <span class="number">5</span></span><br><span class="line"><span class="keyword">when</span> (num &gt; <span class="number">5</span>)&#123;</span><br><span class="line">    <span class="literal">true</span> -&gt; &#123;</span><br><span class="line">        print(<span class="string">&quot;num &gt; 5&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="literal">false</span> -&gt; &#123;</span><br><span class="line">        print(<span class="string">&quot;num &lt; 5&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> -&gt; &#123;</span><br><span class="line">        print(<span class="string">&quot;num = 5&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="检查值是否存在于集合或数组中"><a href="#检查值是否存在于集合或数组中" class="headerlink" title="检查值是否存在于集合或数组中"></a>检查值是否存在于集合或数组中</h3><ol>
<li><p>操作符</p>
<ul>
<li><code>in</code>在</li>
<li><code>!in</code>不在</li>
</ul>
</li>
<li><p>限定：只适用于数值类型</p>
</li>
</ol>
<p>例如：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arrayList = arayOf(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line"><span class="keyword">when</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">in</span> arrayList.toIntArray() -&gt; println(<span class="string">&quot;1 存在于arrayList数组中&quot;</span>)</span><br><span class="line">    <span class="keyword">in</span> <span class="number">0</span> .. <span class="number">10</span> -&gt; println(<span class="string">&quot;1 属于0~10中&quot;</span>)</span><br><span class="line">    !<span class="keyword">in</span> <span class="number">5</span> .<span class="number">.10</span> -&gt; println(<span class="string">&quot;1 不属于5~10中&quot;</span>)</span><br><span class="line">	<span class="keyword">else</span> -&gt; println(<span class="string">&quot;都错了！&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="检查值是否为指定类型的值"><a href="#检查值是否为指定类型的值" class="headerlink" title="检查值是否为指定类型的值"></a>检查值是否为指定类型的值</h3><ol>
<li><p>操作符</p>
<ul>
<li>是<code>is</code></li>
<li>不是<code>!is</code></li>
</ul>
</li>
<li><p>注意：<code>kotlin</code>的智能转换可以访问类型的方法和属性</p>
</li>
</ol>
<p>例如：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">when</span>(<span class="string">&quot;abc&quot;</span>)&#123;</span><br><span class="line">    <span class="keyword">is</span> String -&gt; println(<span class="string">&quot;是字符串&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span> -&gt; println(<span class="string">&quot;不是字符串&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//智能转换</span></span><br><span class="line"><span class="keyword">var</span> a:<span class="built_in">Int</span> = <span class="number">2</span></span><br><span class="line"><span class="keyword">when</span>(a)&#123;</span><br><span class="line">    !<span class="keyword">is</span> <span class="built_in">Int</span> -&gt; println(<span class="string">&quot;<span class="variable">$a</span> 不是一个整型的数&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span> -&gt; &#123;</span><br><span class="line">        a = a.shl(<span class="number">2</span>)</span><br><span class="line">        println(<span class="string">&quot;a =&gt; <span class="variable">$a</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="不使用表达式的when语句"><a href="#不使用表达式的when语句" class="headerlink" title="不使用表达式的when语句"></a>不使用表达式的when语句</h3><p>表示为最简单的布尔表达式</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = arrayOfNulls&lt;String&gt;(<span class="number">3</span>)</span><br><span class="line"><span class="keyword">when</span>&#123;</span><br><span class="line">    <span class="literal">true</span> -&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> array)&#123;</span><br><span class="line">            print(<span class="string">&quot; <span class="variable">$i</span> \t&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        println()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> -&gt; &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="其它语句"><a href="#其它语句" class="headerlink" title="其它语句"></a>其它语句</h2><ul>
<li><p>while语句</p>
</li>
<li><p>do while语句</p>
</li>
<li><p>跳转语句：return，break，continue</p>
</li>
</ul>
<p>与C类语言一致，不做赘述。</p>
<h1 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h1><h2 id="一元操作符"><a href="#一元操作符" class="headerlink" title="一元操作符"></a>一元操作符</h2><h3 id="简单一元"><a href="#简单一元" class="headerlink" title="简单一元"></a>简单一元</h3><table>
<thead>
<tr>
<th align="center">操作符</th>
<th align="center">重载</th>
</tr>
</thead>
<tbody><tr>
<td align="center">+a</td>
<td align="center">a.unaryPlus()</td>
</tr>
<tr>
<td align="center">-a</td>
<td align="center">a.unaryMinus()</td>
</tr>
<tr>
<td align="center">!a</td>
<td align="center">a.not()</td>
</tr>
</tbody></table>
<h3 id="复杂一元"><a href="#复杂一元" class="headerlink" title="复杂一元"></a>复杂一元</h3><table>
<thead>
<tr>
<th align="center">操作符</th>
<th align="center">重载</th>
<th align="center">表示</th>
</tr>
</thead>
<tbody><tr>
<td align="center">a++</td>
<td align="center">a.inc()</td>
<td align="center">a &#x3D; a.also{ a.inc() }</td>
</tr>
<tr>
<td align="center">a–</td>
<td align="center">a.dec()</td>
<td align="center">a &#x3D; a.also{ a.dec() }</td>
</tr>
<tr>
<td align="center">++a</td>
<td align="center">a.inc()</td>
<td align="center">a &#x3D; a.inc().also{ a &#x3D; it }</td>
</tr>
<tr>
<td align="center">–a</td>
<td align="center">a.dec()</td>
<td align="center">a &#x3D; a.dec().also{ a &#x3D; it }</td>
</tr>
</tbody></table>
<h2 id="二元操作符"><a href="#二元操作符" class="headerlink" title="二元操作符"></a>二元操作符</h2><h3 id="简单二元"><a href="#简单二元" class="headerlink" title="简单二元"></a>简单二元</h3><table>
<thead>
<tr>
<th align="center">操作符</th>
<th align="center">重载</th>
</tr>
</thead>
<tbody><tr>
<td align="center">a + b</td>
<td align="center">a.plus(b)</td>
</tr>
<tr>
<td align="center">a - b</td>
<td align="center">a.minus(b)</td>
</tr>
<tr>
<td align="center">a * b</td>
<td align="center">a.tiems(b)</td>
</tr>
<tr>
<td align="center">a &#x2F; b</td>
<td align="center">a.div(b)</td>
</tr>
<tr>
<td align="center">a % b</td>
<td align="center">a.rem(b)</td>
</tr>
<tr>
<td align="center">a .. b</td>
<td align="center">a.rangTo(b)</td>
</tr>
</tbody></table>
<h3 id="复杂二元"><a href="#复杂二元" class="headerlink" title="复杂二元"></a>复杂二元</h3><table>
<thead>
<tr>
<th align="center">操作符</th>
<th align="center">表示</th>
<th align="center">重载</th>
</tr>
</thead>
<tbody><tr>
<td align="center">a +&#x3D; b</td>
<td align="center">a &#x3D; a + b</td>
<td align="center">a &#x3D; a.plus(b)</td>
</tr>
<tr>
<td align="center">a -&#x3D; b</td>
<td align="center">a &#x3D; a - b</td>
<td align="center">a &#x3D; a.minus(b)</td>
</tr>
<tr>
<td align="center">a *&#x3D; b</td>
<td align="center">a &#x3D; a * b</td>
<td align="center">a &#x3D; a.tiems(b)</td>
</tr>
<tr>
<td align="center">a &#x2F;&#x3D; b</td>
<td align="center">a &#x3D; a &#x2F; b</td>
<td align="center">a &#x3D; a.div(b)</td>
</tr>
<tr>
<td align="center">a %&#x3D; b</td>
<td align="center">a &#x3D; a % b</td>
<td align="center">a &#x3D; a.rem(b)</td>
</tr>
</tbody></table>
<h2 id="区间操作"><a href="#区间操作" class="headerlink" title="区间操作"></a>区间操作</h2><p>区间操作符：<code>..</code>，注意两个操作数都是整型</p>
<table>
<thead>
<tr>
<th align="center">操作符</th>
<th align="center">表示</th>
<th align="center">重载</th>
</tr>
</thead>
<tbody><tr>
<td align="center">a .. b</td>
<td align="center">a 到 b 中间的值</td>
<td align="center">a.rangeTo(b)</td>
</tr>
</tbody></table>
<h1 id="进阶操作"><a href="#进阶操作" class="headerlink" title="进阶操作"></a>进阶操作</h1><h2 id="可空类型，空安全"><a href="#可空类型，空安全" class="headerlink" title="可空类型，空安全"></a>可空类型，空安全</h2><h3 id="定义一个可空类型的变量"><a href="#定义一个可空类型的变量" class="headerlink" title="定义一个可空类型的变量"></a>定义一个可空类型的变量</h3><blockquote>
<p><strong>修饰符 变量名 : 类型? &#x3D; 值</strong></p>
</blockquote>
<h3 id="判断可空类型的两种方式"><a href="#判断可空类型的两种方式" class="headerlink" title="判断可空类型的两种方式"></a>判断可空类型的两种方式</h3><ul>
<li><p>if…else… 判断</p>
</li>
<li><p>使用符号<code>?.</code>判断</p>
<p>该符号的用法为：<code>可空类型变量?.属性/方法</code>。如果可空类型变量为null是，返回null；</p>
<p>这种方法大量用于<strong>链式操作</strong>的用法中，能有效避免<code>空引用异常</code>，因为只要链式中有一个<code>null</code>，则整个表达式都为<code>null</code>。</p>
</li>
</ul>
<h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h2><h3 id="let"><a href="#let" class="headerlink" title="let"></a>let</h3><p><code>let</code> 扩展函数的实际上是一个作用域函数，当你需要去定义一个变量在一个<strong>特定的作用域</strong>范围内，<code>let</code> 函数的是一个不错的选择；</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">obj.let &#123;</span><br><span class="line">    <span class="comment">// 用 it 指代 obj 对象</span></span><br><span class="line">    <span class="comment">// todo() 是 obj 对象的共有属性或方法</span></span><br><span class="line">    <span class="comment">// it.todo() 的返回值作为 let 函数的返回值返回</span></span><br><span class="line">    it.todo() </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 另一种用法</span></span><br><span class="line">obj?.let &#123;</span><br><span class="line">    it.todo() <span class="comment">// obj 不为 null 时才会调用 let 函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>使用 let 函数处理需要针对一个可 null 的对象统一做判空处理；</p>
</li>
<li><p>需要去明确一个变量所处特定的作用域范围内可以使用；</p>
</li>
</ul>
<h3 id="with"><a href="#with" class="headerlink" title="with"></a>with</h3><p>和 <code>let</code> 类似，又和 <code>let</code> 不同，<code>with</code> 最后也包含一段函数块，也是将最后的计算的结果返回。</p>
<p>但是 <code>with</code> 不是以拓展的形式存在的。其将某个对象作为函数的参数，并且以 <code>this</code> 指代，可以类比 js 。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">whith(obj) &#123;</span><br><span class="line">  <span class="comment">// todo() 是 obj 对象的共有属性或方法</span></span><br><span class="line">  <span class="comment">// todo() 的返回值作为 with 函数的返回值返回</span></span><br><span class="line">  todo() </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们使用 <code>with</code> 函数的话，由于代码块中传入的是 <code>this</code>，而不是 <code>it</code>，那么我们就可以直接写出函数名（属性）来进行相应的设置：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (textView == <span class="literal">null</span>) <span class="keyword">return</span></span><br><span class="line">with(textView) &#123;</span><br><span class="line">	text = <span class="string">&quot;TextSetInTextView&quot;</span></span><br><span class="line">	setTextColor(ContextCompat.getColor(<span class="keyword">this</span><span class="symbol">@TestActivity</span>, R.color.colorAccent))</span><br><span class="line">	textSize = <span class="number">18f</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码唯一的缺点就是要事先判空了，有没有既能像 let 那样能优雅的判空，又能写出这样的便利的代码呢？</p>
<h3 id="run"><a href="#run" class="headerlink" title="run"></a>run</h3><p>刚刚说到，我们想能有 <code>let</code> 函数那样又优雅的判空，又能有 <code>with</code> 函数省去同一个对象多次设置属性的便捷写法。</p>
<p>没错，就是这就非我们 <code>run</code> 函数莫属了。<code>run</code> 函数基本是 <code>let</code> 和 <code>with</code> 的结合体，对象调用 <code>run</code> 函数，接收一个 <code>lambda</code> 函数为参数，传入 <code>this</code> 并以闭包形式返回，返回值是最后的计算结果。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">obj.run &#123;</span><br><span class="line">  <span class="comment">// todo() 是 obj 对象的共有属性或方法</span></span><br><span class="line">  <span class="comment">// todo() 的返回值作为 run 函数的返回值返回</span></span><br><span class="line">  todo() </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么上面 TextView 设置各种属性的优化写法就是这样的：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">textView?.run &#123;</span><br><span class="line">	text = <span class="string">&quot;TextSetInTextView&quot;</span></span><br><span class="line">	setTextColor(ContextCompat.getColor(<span class="keyword">this</span><span class="symbol">@TestActivity</span>, R.color.colorAccent))</span><br><span class="line">	textSize = <span class="number">18f</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>像上面这个例子，在需要多次设置属性，但设置属性后返回值不是该对象（或无返回值：Unit）不能链式调用的时候，就非常适合使用 <code>run</code> 函数。</p>
<h3 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h3><p><code>apply</code> 函数和 <code>run</code> 函数很像，但是 <code>apply</code> 最后返回的是调用对象自身。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> result = obj.apply &#123;</span><br><span class="line">  <span class="comment">// todo() 是 obj 对象的共有属性或方法</span></span><br><span class="line">  todo() </span><br><span class="line">  <span class="number">3</span> * <span class="number">4</span> <span class="comment">// 最后返回的是 obj 对象，而不是 12</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">println(result) <span class="comment">// 打印的是 obj 对象</span></span><br></pre></td></tr></table></figure>

<p>由于 <code>apply</code> 函数返回的是调用对象自身，我们可以借助 <code>apply</code> 函数的特性进行多级判空。</p>
<h3 id="also"><a href="#also" class="headerlink" title="also"></a>also</h3><p>和 <code>let</code> 函数类似，唯一的区别就是 <code>also</code> 函数的返回值是调用对象本身：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> result = obj.also &#123;</span><br><span class="line">    <span class="comment">// 用 it 指代 obj 对象</span></span><br><span class="line">    <span class="comment">// todo() 是 obj 对象的共有属性或方法</span></span><br><span class="line">    it.todo() </span><br><span class="line">  	<span class="number">3</span> * <span class="number">4</span> <span class="comment">// 将返回 obj 对象，而不是 12</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>函数定义见下表：</p>
<table>
<thead>
<tr>
<th>函数名</th>
<th>实现</th>
</tr>
</thead>
<tbody><tr>
<td>let</td>
<td>public inline fun &lt;T, R&gt; T.let(block: (T) -&gt; R): R &#x3D; block(this)</td>
</tr>
<tr>
<td>with</td>
<td>public inline fun &lt;T, R&gt; with(receiver: T, block: T.() -&gt; R): R &#x3D; receiver.block()</td>
</tr>
<tr>
<td>run</td>
<td>public inline fun &lt;T, R&gt; T.run(block: T.() -&gt; R): R &#x3D; block()</td>
</tr>
<tr>
<td>apply</td>
<td>public inline fun  T.apply(block: T.() -&gt; Unit): T { block(); return this }</td>
</tr>
<tr>
<td>also</td>
<td>public inline fun T.also(block: (T) -&gt; Unit): T { block(this); return this }</td>
</tr>
</tbody></table>
<p>具体的调用情况见下图：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">graph TB</span><br><span class="line">如何选择函数 --&gt; |根据返回值| Usage&#123;this/计算结果&#125;</span><br><span class="line">Usage --&gt; |返回计算结果| Result&#123;传递 it/this&#125;</span><br><span class="line">Usage --&gt; |返回 this| This&#123;传递 it/this&#125;</span><br><span class="line"></span><br><span class="line">This --&gt; |this| A[&quot;T.apply &#123; this &#125;: T&quot;]</span><br><span class="line">This --&gt; |it| B[&quot;T.also &#123; this &#125;: T&quot;]</span><br><span class="line">Result --&gt; |this| C[&quot;T.run &#123; this &#125;: 计算结果&quot;]</span><br><span class="line">C --&gt; |函数直接调用| D[&quot;with(T) &#123; this &#125;: 计算结果&quot;]</span><br><span class="line">Result --&gt; |it| E[&quot;T.let &#123; it &#125;: 计算结果&quot;]</span><br></pre></td></tr></table></figure>

<h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><p>kotlin 中的类成员包括：构造函数、初始化代码块、成员函数、属性、<strong>内部类和嵌套类</strong>、以及<strong>对象表达式声明</strong>。</p>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><ul>
<li><p>在 Kotlin 中的一个类可以有一个<strong>主构造函数</strong>以及一个或多个<strong>次构造函数</strong>，主构造函数是类头的一部分：它跟在类名（与可选的类型参数）后；</p>
</li>
<li><p>如果主构造函数没有任何注解或者可见性修饰符，可以省略这个 <em>constructor</em> 关键字：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">constructor</span>(firstName: String) &#123; <span class="comment">/*……*/</span> &#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(firstName: String) &#123; <span class="comment">/*……*/</span> &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>主构造函数不能包含任何的代码。初始化的代码可以放到以 <em>init</em> 关键字作为前缀的<strong>初始化块（initializer blocks）</strong>中，主构造的参数可以在初始化块中使用。它们也可以在类体内声明的属性初始化器中使用：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">constructor</span>(firstName: String) &#123;</span><br><span class="line">    <span class="keyword">var</span> name = firstName</span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        println(<span class="string">&quot;name: <span class="subst">$&#123;firstName&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>类也可以声明前缀有 <em>constructor</em>的<strong>次构造函数</strong>，每个次构造函数需要委托给主构造函数， 可以直接委托或者通过别的次构造函数间接委托。委托到同一个类的另一个构造函数用 <em><strong><code>this</code></strong></em> 关键字即可；</p>
</li>
<li><p>初始化块中的代码实际上会成为主构造函数的一部分。委托给主构造函数会作为次构造函数的第一条语句，因此所有初始化块与属性初始化器中的代码都会在次构造函数体之前执行。即使该类没有主构造函数，这种委托仍会隐式发生，并且仍会执行初始化块；</p>
</li>
</ul>
<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><p>声明一个属性的完整语法：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> &lt;propertyName&gt;[: &lt;PropertyType&gt;] [= &lt;property_initializer&gt;]</span><br><span class="line">    [&lt;getter&gt;]</span><br><span class="line">    [&lt;setter&gt;]</span><br></pre></td></tr></table></figure>

<p>其初始器（initializer）、getter 和 setter 都是可选的。属性类型如果可以从初始器中推断出来，也可以省略。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> isEmpty: <span class="built_in">Boolean</span></span><br><span class="line">    <span class="keyword">get</span>() = <span class="keyword">this</span>.size == <span class="number">0</span></span><br></pre></td></tr></table></figure>

<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><ul>
<li>在 Kotlin 中所有类都有一个共同的超类 <code>Any</code>，这对于没有超类型声明的类是<strong>默认超类</strong>；</li>
<li>默认情况下，Kotlin 类是最终（final）的：它们不能被继承。 要使一个类可继承，请用 <code>open</code> 关键字标记它；</li>
</ul>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>Kotlin 的接口可以既包含抽象方法的声明也包含实现。与抽象类不同的是，接口无法保存状态。它可以有属性但必须声明为抽象或提供访问器实现。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">MyInterface</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">bar</span><span class="params">()</span></span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">      <span class="comment">// 可选的方法体</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="数据类"><a href="#数据类" class="headerlink" title="数据类"></a>数据类</h2><p>编译器自动从主构造函数中声明的所有属性导出以下成员：</p>
<ul>
<li><code>equals()</code>&#x2F;<code>hashCode()</code> 对；</li>
<li><code>toString()</code> 格式是 <code>&quot;User(name=John, age=42)&quot;</code>；</li>
<li><code>componentN()</code> 函数按声明顺序对应于所有属性；</li>
<li><code>copy()</code> 函数；</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">User</span>(<span class="keyword">val</span> name: String, <span class="keyword">val</span> age: <span class="built_in">Int</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>主构造函数需要至少有一个参数。</li>
<li>主构造函数的所有参数需要标记为 <code>val</code> 或 <code>var</code>。</li>
<li>数据类不能是抽象、开放、密封或者内部的。</li>
</ul>

      </div>
      
        <div class="prev-or-next">
          <div class="post-foot-next">
            
              <a href="/2019/07/13/stm32-8/" target="_self">
                <i class="iconfont icon-chevronleft"></i>
                <span>Prev</span>
              </a>
            
          </div>
          <div class="post-attach">
            <span class="post-pubtime">
              <i class="iconfont icon-updatetime mr-10" title="Update time"></i>
              2019-07-14 23:01:25
            </span>
            
                  <span class="post-tags">
                    <i class="iconfont icon-tags mr-10" title="Tags"></i>
                    
                    <span class="span--tag mr-8">
                      <a href="/tags/Kotlin/" title="Kotlin">
                        #Kotlin
                      </a>
                    </span>
                    
                  </span>
              
          </div>
          <div class="post-foot-prev">
            
              <a href="/2019/07/25/stm32-5/" target="_self">
                <span>Next</span>
                <i class="iconfont icon-chevronright"></i>
              </a>
            
          </div>
        </div>
      
    </div>
    
  <div id="btn-catalog" class="btn-catalog">
    <i class="iconfont icon-catalog"></i>
  </div>
  <div class="post-catalog hidden" id="catalog">
    <div class="title">Contents</div>
    <div class="catalog-content">
      
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D"><span class="toc-text">简单介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E5%8C%85"><span class="toc-text">定义包</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0"><span class="toc-text">定义函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E5%8F%98%E9%87%8F"><span class="toc-text">定义变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E9%87%8A"><span class="toc-text">注释</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A8%A1%E6%9D%BF"><span class="toc-text">使用字符串模板</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E%E5%8F%AF%E7%A9%BA%E5%8F%98%E9%87%8F"><span class="toc-text">声明可空变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F%E7%9A%84%E7%94%A8%E6%B3%95"><span class="toc-text">常量的用法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B"><span class="toc-text">数值类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%95%B0%E5%AD%97%E7%9A%84%E5%86%85%E7%BD%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">1. 数字的内置类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%BF%9B%E5%88%B6%E6%95%B0"><span class="toc-text">2. 进制数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%95%B0%E5%AD%97%E7%B1%BB%E5%9E%8B%E5%AD%97%E9%9D%A2%E5%B8%B8%E9%87%8F%E7%9A%84%E4%B8%8B%E5%88%92%E7%BA%BF"><span class="toc-text">3. 数字类型字面常量的下划线</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E8%A3%85%E7%AE%B1%E4%B8%8E%E6%8B%86%E7%AE%B1"><span class="toc-text">4. 装箱与拆箱</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%80%BC%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-text">两个数值的比较</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E8%BD%AC%E6%8D%A2"><span class="toc-text">5. 转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">6. 位运算符</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%83%E5%B0%94%E7%B1%BB%E5%9E%8B"><span class="toc-text">布尔类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">1. 关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E9%80%BB%E8%BE%91%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-text">2. 逻辑操作符</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E5%9E%8B"><span class="toc-text">字符型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%85%B3%E9%94%AE%E5%AD%97-1"><span class="toc-text">1. 关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%98%BE%E7%A4%BA%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%85%B6%E4%BB%96%E7%B1%BB%E5%9E%8B"><span class="toc-text">2. 显示转换为其他类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%AD%97%E7%AC%A6%E8%BD%AC%E4%B9%89"><span class="toc-text">3. 字符转义</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B"><span class="toc-text">字符串类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%85%B3%E9%94%AE%E5%AD%97-2"><span class="toc-text">1. 关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%97%E9%9D%A2%E9%87%8F"><span class="toc-text">2. 字符串字面量</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%9E%8B"><span class="toc-text">数组型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-arrayOf"><span class="toc-text">1. arrayOf()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-arrayOfNulls"><span class="toc-text">2. arrayOfNulls()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%B7%A5%E5%8E%82%E5%87%BD%E6%95%B0"><span class="toc-text">3. 工厂函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%8E%9F%E5%A7%8B%E7%B1%BB%E5%9E%8B%E6%95%B0%E7%BB%84"><span class="toc-text">4. 原始类型数组</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5"><span class="toc-text">控制语句</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#if%E8%AF%AD%E5%8F%A5"><span class="toc-text">if语句</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BC%A0%E7%BB%9F%E5%86%99%E6%B3%95"><span class="toc-text">1. 传统写法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Kotlin%E4%B8%AD%E7%9A%84%E4%B8%89%E5%85%83%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">2. Kotlin中的三元运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%BD%9C%E4%B8%BA%E4%B8%80%E4%B8%AA%E5%9D%97%E7%BB%93%E6%9E%84%EF%BC%8C%E5%B9%B6%E4%B8%94%E6%9C%80%E5%90%8E%E4%B8%80%E5%8F%A5%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%BA%E5%9D%97%E7%9A%84%E5%80%BC"><span class="toc-text">3. 作为一个块结构，并且最后一句表达式为块的值</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#for%E8%AF%AD%E5%8F%A5"><span class="toc-text">for语句</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%84%E5%88%99"><span class="toc-text">规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%8D%E5%8E%86%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">遍历字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%8D%E5%8E%86%E6%95%B0%E7%BB%84"><span class="toc-text">遍历数组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%88%97%E8%A1%A8%E6%88%96%E6%95%B0%E7%BB%84%E7%9A%84%E6%89%A9%E5%B1%95%E5%87%BD%E6%95%B0%E9%81%8D%E5%8E%86"><span class="toc-text">使用列表或数组的扩展函数遍历</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#when%E8%AF%AD%E5%8F%A5"><span class="toc-text">when语句</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0switch%E8%AF%AD%E5%8F%A5%E5%8A%9F%E8%83%BD"><span class="toc-text">实现switch语句功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8E%E9%80%97%E5%8F%B7%E7%BB%93%E5%90%88"><span class="toc-text">与逗号结合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%E4%BB%BB%E6%84%8F%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text">条件可以使用任意表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A3%80%E6%9F%A5%E5%80%BC%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E4%BA%8E%E9%9B%86%E5%90%88%E6%88%96%E6%95%B0%E7%BB%84%E4%B8%AD"><span class="toc-text">检查值是否存在于集合或数组中</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A3%80%E6%9F%A5%E5%80%BC%E6%98%AF%E5%90%A6%E4%B8%BA%E6%8C%87%E5%AE%9A%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%80%BC"><span class="toc-text">检查值是否为指定类型的值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E4%BD%BF%E7%94%A8%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84when%E8%AF%AD%E5%8F%A5"><span class="toc-text">不使用表达式的when语句</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B6%E5%AE%83%E8%AF%AD%E5%8F%A5"><span class="toc-text">其它语句</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-text">操作符</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E5%85%83%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-text">一元操作符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E4%B8%80%E5%85%83"><span class="toc-text">简单一元</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E4%B8%80%E5%85%83"><span class="toc-text">复杂一元</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%85%83%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-text">二元操作符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E4%BA%8C%E5%85%83"><span class="toc-text">简单二元</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E4%BA%8C%E5%85%83"><span class="toc-text">复杂二元</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%BA%E9%97%B4%E6%93%8D%E4%BD%9C"><span class="toc-text">区间操作</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%9B%E9%98%B6%E6%93%8D%E4%BD%9C"><span class="toc-text">进阶操作</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E7%A9%BA%E7%B1%BB%E5%9E%8B%EF%BC%8C%E7%A9%BA%E5%AE%89%E5%85%A8"><span class="toc-text">可空类型，空安全</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E5%8F%AF%E7%A9%BA%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8F%98%E9%87%8F"><span class="toc-text">定义一个可空类型的变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E5%8F%AF%E7%A9%BA%E7%B1%BB%E5%9E%8B%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-text">判断可空类型的两种方式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0"><span class="toc-text">高阶函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#let"><span class="toc-text">let</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#with"><span class="toc-text">with</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#run"><span class="toc-text">run</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#apply"><span class="toc-text">apply</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#also"><span class="toc-text">also</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-text">面向对象</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-text">构造函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7"><span class="toc-text">属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-text">继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3"><span class="toc-text">接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB"><span class="toc-text">数据类</span></a></li></ol></li></ol>
      
    </div>
  </div>

  
<script src="/js/catalog.js"></script>




    
      <div class="comments-container">
        







      </div>
    
  </div>


        
<div class="footer">
  <div class="social">
    <ul>
      
        <li>
          <a title="github" target="_blank" rel="noopener" href="https://github.com/zchengsite/hexo-theme-oranges">
            <i class="iconfont icon-github"></i>
          </a>
        </li>
      
    </ul>
  </div>
  
    
    <div class="footer-more">
      
        <a target="_blank" rel="noopener" href="https://github.com/zchengsite/hexo-theme-oranges">Copyright © 2024 Oranges</a>
        
    </div>
  
    
    <div class="footer-more">
      
        <a target="_blank" rel="noopener" href="https://github.com/zchengsite/hexo-theme-oranges">Theme by Oranges | Powered by Hexo</a>
        
    </div>
  
  
</div>

      </div>

      <div class="tools-bar">
        <div class="back-to-top tools-bar-item hidden">
  <a href="javascript: void(0)">
    <i class="iconfont icon-chevronup"></i>
  </a>
</div>


<script src="/js/backtotop.js"></script>



        
  <div class="search-icon tools-bar-item" id="search-icon">
    <a href="javascript: void(0)">
      <i class="iconfont icon-search"></i>
    </a>
  </div>

  <div class="search-overlay hidden">
    <div class="search-content" tabindex="0">
      <div class="search-title">
        <span class="search-icon-input">
          <a href="javascript: void(0)">
            <i class="iconfont icon-search"></i>
          </a>
        </span>
        
          <input type="text" class="search-input" id="search-input" placeholder="Search...">
        
        <span class="search-close-icon" id="search-close-icon">
          <a href="javascript: void(0)">
            <i class="iconfont icon-close"></i>
          </a>
        </span>
      </div>
      <div class="search-result" id="search-result"></div>
    </div>
  </div>

  <script type="text/javascript">
    var inputArea = document.querySelector("#search-input")
    var searchOverlayArea = document.querySelector(".search-overlay")

    inputArea.onclick = function() {
      getSearchFile()
      this.onclick = null
    }

    inputArea.onkeydown = function() {
      if(event.keyCode == 13)
        return false
    }

    function openOrHideSearchContent() {
      let isHidden = searchOverlayArea.classList.contains('hidden')
      if (isHidden) {
        searchOverlayArea.classList.remove('hidden')
        document.body.classList.add('hidden')
        // inputArea.focus()
      } else {
        searchOverlayArea.classList.add('hidden')
        document.body.classList.remove('hidden')
      }
    }

    function blurSearchContent(e) {
      if (e.target === searchOverlayArea) {
        openOrHideSearchContent()
      }
    }

    document.querySelector("#search-icon").addEventListener("click", openOrHideSearchContent, false)
    document.querySelector("#search-close-icon").addEventListener("click", openOrHideSearchContent, false)
    searchOverlayArea.addEventListener("click", blurSearchContent, false)

    var searchFunc = function (path, search_id, content_id) {
      'use strict';
      var $input = document.getElementById(search_id);
      var $resultContent = document.getElementById(content_id);
      $resultContent.innerHTML = "<ul><span class='local-search-empty'>First search, index file loading, please wait...<span></ul>";
      $.ajax({
        // 0x01. load xml file
        url: path,
        dataType: "xml",
        success: function (xmlResponse) {
          // 0x02. parse xml file
          var datas = $("entry", xmlResponse).map(function () {
            return {
              title: $("title", this).text(),
              content: $("content", this).text(),
              url: $("url", this).text()
            };
          }).get();
          $resultContent.innerHTML = "";

          $input.addEventListener('input', function () {
            // 0x03. parse query to keywords list
            var str = '<ul class=\"search-result-list\">';
            var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
            $resultContent.innerHTML = "";
            if (this.value.trim().length <= 0) {
              return;
            }
            // 0x04. perform local searching
            datas.forEach(function (data) {
              var isMatch = true;
              var content_index = [];
              if (!data.title || data.title.trim() === '') {
                data.title = "Untitled";
              }
              var orig_data_title = data.title.trim();
              var data_title = orig_data_title.toLowerCase();
              var orig_data_content = data.content.trim().replace(/<[^>]+>/g, "");
              var data_content = orig_data_content.toLowerCase();
              var data_url = data.url;
              var index_title = -1;
              var index_content = -1;
              var first_occur = -1;
              // only match artiles with not empty contents
              if (data_content !== '') {
                keywords.forEach(function (keyword, i) {
                  index_title = data_title.indexOf(keyword);
                  index_content = data_content.indexOf(keyword);

                  if (index_title < 0 && index_content < 0) {
                    isMatch = false;
                  } else {
                    if (index_content < 0) {
                      index_content = 0;
                    }
                    if (i == 0) {
                      first_occur = index_content;
                    }
                    // content_index.push({index_content:index_content, keyword_len:keyword_len});
                  }
                });
              } else {
                isMatch = false;
              }
              // 0x05. show search results
              if (isMatch) {
                str += "<li><a href='" + data_url + "' class='search-result-title'>" + orig_data_title + "</a>";
                var content = orig_data_content;
                if (first_occur >= 0) {
                  // cut out 100 characters
                  var start = first_occur - 20;
                  var end = first_occur + 80;

                  if (start < 0) {
                    start = 0;
                  }

                  if (start == 0) {
                    end = 100;
                  }

                  if (end > content.length) {
                    end = content.length;
                  }

                  var match_content = content.substr(start, end);

                  // highlight all keywords
                  keywords.forEach(function (keyword) {
                    var regS = new RegExp(keyword, "gi");
                    match_content = match_content.replace(regS, "<span class=\"search-keyword\">" + keyword + "</span>");
                  });

                  str += "<p class=\"search-result-abstract\">" + match_content + "...</p>"
                }
                str += "</li>";
              }
            });
            str += "</ul>";
            if (str.indexOf('<li>') === -1) {
              return $resultContent.innerHTML = "<ul><span class='local-search-empty'>No result<span></ul>";
            }
            $resultContent.innerHTML = str;
          });
        },
        error: function(xhr, status, error) {
          $resultContent.innerHTML = ""
          if (xhr.status === 404) {
            $resultContent.innerHTML = "<ul><span class='local-search-empty'>The search.xml file was not found, please refer to：<a href='https://github.com/zchengsite/hexo-theme-oranges#configuration' target='_black'>configuration</a><span></ul>";
          } else {
            $resultContent.innerHTML = "<ul><span class='local-search-empty'>The request failed, Try to refresh the page or try again later.<span></ul>";
          }
        }
      });
      $(document).on('click', '#search-close-icon', function() {
        $('#search-input').val('');
        $('#search-result').html('');
      });
    }

    var getSearchFile = function() {
        var path = "/search.xml";
        searchFunc(path, 'search-input', 'search-result');
    }
  </script>




        
  <div class="tools-bar-item theme-icon" id="switch-color-scheme">
    <a href="javascript: void(0)">
      <i id="theme-icon" class="iconfont icon-moon"></i>
    </a>
  </div>

  
<script src="/js/colorscheme.js"></script>





        
  
    <div class="share-icon tools-bar-item">
      <a href="javascript: void(0)" id="share-icon">
        <i class="iconfont iconshare"></i>
      </a>
      <div class="share-content hidden">
        
          <a class="share-item" href="https://twitter.com/intent/tweet?text=' + Kotlin%20%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0 + '&url=' + http%3A%2F%2Fblog.mahoo12138.cn%2F2019%2F07%2F14%2Fandroid-5%2F + '" target="_blank" title="Twitter">
            <i class="iconfont icon-twitter"></i>
          </a>
        
        
          <a class="share-item" href="https://www.facebook.com/sharer.php?u=http://blog.mahoo12138.cn/2019/07/14/android-5/" target="_blank" title="Facebook">
            <i class="iconfont icon-facebooksquare"></i>
          </a>
        
      </div>
    </div>
  
  
<script src="/js/shares.js"></script>



      </div>
    </div>
  </body>
</html>
