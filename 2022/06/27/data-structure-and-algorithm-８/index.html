<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><title>数据结构与算法学习之AVL树 [ Mahoo12138 ]</title><link rel="stylesheet" href="/css/index.css"><meta name="post"><link rel="stylesheet" href="/css/layouts/post.css"><meta name="generator" content="Hexo 7.3.0"></head><body><div id="hexo-container"><header></header><main id="content"><article id="post"><h1>数据结构与算法学习之AVL树</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>AVL 是最早发明的自平衡二叉搜索树之一，名称来源于 G. M. <strong>A</strong>delson-<strong>V</strong>elsky 和 E. M. <strong>L</strong>andis (两位来自苏联的科学家)；</p>
<p><strong>平衡因子</strong>：某节点的左右子树的高度差；</p>
<p>而在 AVL 树中每个节点的平衡因子只能是 1，0，-1；</p>
<p>即绝对值 ≤ 1，大于 1 则称之为<strong>失衡</strong>；也就是说每个节点的左右子树高度差不超过 1；搜索、添加、删除的时间复杂度是 O(logn)；</p>
<h2 id="添加的失衡"><a href="#添加的失衡" class="headerlink" title="添加的失衡"></a>添加的失衡</h2><p>当在二叉搜索树中添加一个元素时，最坏的情况可能会导致所有祖先都失衡，父节点其他的非祖先节点不会失衡；</p>
<p>添加导致的失衡可以通过旋转节点进行调整高度，达到重新平衡，有四种情况：</p>
<h3 id="LL-右旋转"><a href="#LL-右旋转" class="headerlink" title="LL - 右旋转"></a>LL - 右旋转</h3><p><img src="https://cdn.jsdelivr.net/gh/mahoo12138/js-css-cdn/hexo-images/study/algorithm/LL.png"></p>
<p>首先解释一下这个分类名称，<strong>LL</strong> 表示新添加的节点 n 是在由其导致失衡的最近的祖先节点即 g 节点的 left 的 left 处；而有右旋转是将这种失衡状态重新平衡的方法，即：</p>
<ul>
<li><code>g.left = p.right</code></li>
<li><code>p.right = g</code></li>
<li>让 p 成为该子树的根节点</li>
<li>维护 parent 以及更新节点高度</li>
</ul>
<p>经过旋转之后，仍然是一颗二叉搜索树：T0 &lt; n &lt; T1 &lt; p &lt; T2 &lt; g &lt; T3；</p>
<h3 id="RR-左旋转"><a href="#RR-左旋转" class="headerlink" title="RR - 左旋转"></a>RR - 左旋转</h3><p><img src="https://cdn.jsdelivr.net/gh/mahoo12138/js-css-cdn/hexo-images/study/algorithm/RR.png" alt="RR"></p>
<ul>
<li><code>g.right= p.left</code></li>
<li><code>p.left= g</code></li>
<li>让 p 成为该子树的根节点；</li>
<li>维护 parent 以及更新节点高度；</li>
</ul>
<h3 id="LR-左旋转，右旋转"><a href="#LR-左旋转，右旋转" class="headerlink" title="LR - 左旋转，右旋转"></a>LR - 左旋转，右旋转</h3><p><img src="https://cdn.jsdelivr.net/gh/mahoo12138/js-css-cdn/hexo-images/study/algorithm/LR.png"></p>
<p>经过两次旋转：先将 p 节点左旋，即形成 LL 情况，再右旋 g 节点；</p>
<h3 id="RL-右旋转，左旋转"><a href="#RL-右旋转，左旋转" class="headerlink" title="RL - 右旋转，左旋转"></a>RL - 右旋转，左旋转</h3><p><img src="https://cdn.jsdelivr.net/gh/mahoo12138/js-css-cdn/hexo-images/study/algorithm/RL.png"></p>
<p>经过两次旋转：先将 p 节点右旋，即形成 RR 情况，再左旋 g 节点；</p>
<h2 id="失衡调整"><a href="#失衡调整" class="headerlink" title="失衡调整"></a>失衡调整</h2><p>我们在<code>BinarySearchTree</code>内部添加一个空方法<code>afterAdd</code>，每次添加后调用该方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(E element)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">null</span>) &#123;</span><br><span class="line">        size++;</span><br><span class="line">        afterAdd(root);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    size++;</span><br><span class="line">    afterAdd(newNode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后让<code>AVL</code>继承<code>BinarySearchTree</code>，重写<code>afterAdd</code>方法，即可完成失衡调整逻辑；</p>
<p>失衡调整逻辑如下：</p>
<ul>
<li>沿着添加的节点的<code>parent</code>属性，往上找；</li>
<li>找到<strong>最近的失衡节点</strong>，进行旋转调整；</li>
</ul>
<p>那么如何判断一个节点是否失衡呢，当然是检测其平衡因子了，即需要一个方法返回检测结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">AVLNode</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">Node</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">height</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AVLNode</span><span class="params">(E element, Node&lt;E&gt; parent)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(element, parent);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">balanceFactor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftHeight</span> <span class="operator">=</span> left == <span class="literal">null</span> ? <span class="number">0</span> : ((AVLNode&lt;E&gt;)left).height;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightHeight</span> <span class="operator">=</span> right == <span class="literal">null</span> ? <span class="number">0</span> : ((AVLNode&lt;E&gt;)right).height;</span><br><span class="line">        <span class="keyword">return</span> leftHeight - rightHeight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isBanlance</span><span class="params">(Node&lt;E&gt; node)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Math.abs(((AVLNode&lt;E&gt;)node).balanceFactor()) &lt;= <span class="number">1</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此，在 AVL 树中也定义了一个 AVL 节点类继承自二叉树的节点类，还需要修改搜索二叉树中创建逻辑（创建的是默认的节点）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BinaryTree.java</span></span><br><span class="line"><span class="keyword">protected</span> Node&lt;E&gt; <span class="title function_">createNode</span><span class="params">(E element, Node&lt;E&gt; parent)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Node</span>&lt;E&gt;(element, parent); </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// BinarySearchTree.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(E element)</span> &#123;</span><br><span class="line">    <span class="comment">// root = new Node&lt;E&gt;(element, null); </span></span><br><span class="line">    root = createNode(element, <span class="literal">null</span>); </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// AVLTree.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> Node&lt;E&gt; <span class="title function_">createNode</span><span class="params">(E element, Node&lt;E&gt; parent)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AVLNode</span>&lt;&gt;(element, parent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="更新高度"><a href="#更新高度" class="headerlink" title="更新高度"></a>更新高度</h3><p>每次添加的新节点，高度是 1，即在<code>AVLNode</code>中的初始值为 1；之后沿着<code>parent</code>属性往上遍历，主要情况有三种：</p>
<ul>
<li>祖先节点的高度平衡的，那么更新高度；</li>
<li>祖先节点的高度不平衡，即调整失衡；</li>
<li>遍历到祖先节点为 null，停止；</li>
</ul>
<p>由此，需要编写一个更新高度的私有方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">updateHeight</span><span class="params">(Node&lt;E&gt; node)</span>&#123;</span><br><span class="line">    ((AVLNode&lt;E&gt;)node).updateHeight();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">AVLNode</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">Node</span>&lt;E&gt; &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateHeight</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">leftHeight</span> <span class="operator">=</span> left == <span class="literal">null</span> ? <span class="number">0</span> : ((AVLNode&lt;E&gt;)left).height;</span><br><span class="line">		<span class="type">int</span> <span class="variable">rightHeight</span> <span class="operator">=</span> right == <span class="literal">null</span> ? <span class="number">0</span> : ((AVLNode&lt;E&gt;)right).height;</span><br><span class="line">		height = <span class="number">1</span> + Math.max(leftHeight, rightHeight);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="恢复平衡"><a href="#恢复平衡" class="headerlink" title="恢复平衡"></a>恢复平衡</h3><p>当往上遍历时，检测到失衡节点，即需要进行调整，那么就需要对几种类型（RR，LL等）进行判断，那么还需要几个简单的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BinaryTree.java</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;E&gt;&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isLeftChild</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> parent != <span class="literal">null</span> &amp;&amp; <span class="built_in">this</span> == parent.left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isRightChild</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> parent != <span class="literal">null</span> &amp;&amp; <span class="built_in">this</span> == parent.right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了调整失衡节点 g ，我们还需要获取到构成结构的 p 节点和 n 节点，通过上述的结构图，不难观察到 p 是 g 的高度较大的子节点，同样 n 也如出一辙，即还需要一个获取高度更高的子节点的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">AVLNode</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">Node</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> Node&lt;E&gt; <span class="title function_">tallerChild</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftHeight</span> <span class="operator">=</span> left == <span class="literal">null</span> ? <span class="number">0</span> : ((AVLNode&lt;E&gt;)left).height;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightHeight</span> <span class="operator">=</span> right == <span class="literal">null</span> ? <span class="number">0</span> : ((AVLNode&lt;E&gt;)right).height;</span><br><span class="line">        <span class="keyword">if</span>(leftHeight &gt; rightHeight) <span class="keyword">return</span> left;</span><br><span class="line">        <span class="keyword">if</span>(rightHeight &gt; leftHeight) <span class="keyword">return</span> right;</span><br><span class="line">        <span class="keyword">return</span> isLeftChild() ? left : right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么恢复平衡的方法也就很自然的写出来了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">afterAdd</span><span class="params">(Node&lt;E&gt; node)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>((node = node.parent) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(isBanlance(node)) &#123;</span><br><span class="line">            updateHeight(node); <span class="comment">// 更新高度</span></span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            rebalance(node); <span class="comment">// 恢复平衡</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="旋转方向判断"><a href="#旋转方向判断" class="headerlink" title="旋转方向判断"></a>旋转方向判断</h3><p>有了上述的基本判断方法和逻辑框架，那么就可以编写失衡调整的方法了，其中主要涉及的是结构的旋转方向的判断，根据节点之间的连线，也就是<code>isLeftChild</code>或<code>isRightChild</code>方法即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">rebalance</span><span class="params">(Node&lt;E&gt; grand)</span> &#123;</span><br><span class="line">    Node&lt;E&gt; parent = ((AVLNode&lt;E&gt;)grand).tallerChild();</span><br><span class="line">    Node&lt;E&gt; node = ((AVLNode&lt;E&gt;)parent).tallerChild();</span><br><span class="line">    <span class="keyword">if</span>(parent.isLeftChild()) &#123; <span class="comment">// L</span></span><br><span class="line">        <span class="keyword">if</span>(node.isLeftChild()) &#123; <span class="comment">// LL</span></span><br><span class="line">            rotateRight(grand);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123; <span class="comment">// LR</span></span><br><span class="line">            rotateLeft(parent);</span><br><span class="line">            rotateRight(grand);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;	<span class="comment">// R</span></span><br><span class="line">        <span class="keyword">if</span>(node.isLeftChild()) &#123; <span class="comment">// RL</span></span><br><span class="line">            rotateRight(parent);</span><br><span class="line">            rotateLeft(grand);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123; <span class="comment">//RR</span></span><br><span class="line">            rotateLeft(grand);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="左旋实现"><a href="#左旋实现" class="headerlink" title="左旋实现"></a>左旋实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">rotateLeft</span><span class="params">(Node&lt;E&gt; grand)</span>&#123;</span><br><span class="line">    Node&lt;E&gt; parent = grand.right;</span><br><span class="line">    Node&lt;E&gt; child = parent.left;</span><br><span class="line">    <span class="comment">// 旋转</span></span><br><span class="line">    grand.right = child;</span><br><span class="line">    parent.left = grand;</span><br><span class="line">    afterRotate(grand, parent, child);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="右旋实现"><a href="#右旋实现" class="headerlink" title="右旋实现"></a>右旋实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">rotateRight</span><span class="params">(Node&lt;E&gt; grand)</span>&#123;</span><br><span class="line">    Node&lt;E&gt; parent = grand.left;</span><br><span class="line">    Node&lt;E&gt; child = parent.right;</span><br><span class="line">    <span class="comment">// 旋转</span></span><br><span class="line">    grand.left = child;</span><br><span class="line">    parent.right = grand;</span><br><span class="line">    afterRotate(grand, parent, child);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为无论是左旋还是右旋，后序的维护 parent 和更新高度的代码都是一样的，所以抽离到了一个函数中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">afterRotate</span><span class="params">(Node&lt;E&gt; grand,Node&lt;E&gt; parent,Node&lt;E&gt; child)</span> &#123;</span><br><span class="line">    <span class="comment">// 维护 parent --&gt; grand.parent, parent 成为子树根节点 </span></span><br><span class="line">    parent.parent = grand.parent;</span><br><span class="line">    <span class="keyword">if</span>(grand.isLeftChild()) &#123;</span><br><span class="line">        grand.parent.left = parent;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(grand.isRightChild())&#123;</span><br><span class="line">        grand.parent.right = parent;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        root = parent;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 维护 grand --&gt; parent</span></span><br><span class="line">    grand.parent = parent;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 维护 child --&gt; grand</span></span><br><span class="line">    <span class="keyword">if</span>(child != <span class="literal">null</span>) &#123;</span><br><span class="line">        child.parent = grand;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新高度</span></span><br><span class="line">    updateHeight(grand);</span><br><span class="line">    updateHeight(parent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="统一旋转操作"><a href="#统一旋转操作" class="headerlink" title="统一旋转操作"></a>统一旋转操作</h2><h2 id="删除的失衡"><a href="#删除的失衡" class="headerlink" title="删除的失衡"></a>删除的失衡</h2><ul>
<li>只可能会导致父节点或祖先节点失衡，其他节点都不可能失衡；</li>
<li>删除节点进行一次失衡调整后，更高层的祖先节点也可能失衡，需要再次调整，往复……</li>
</ul>
<p>那么只需要将添加失衡调整代码中的一次调整后的<code>break</code>语句删除即可，其他的操作一致：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">afterRemove</span><span class="params">(Node&lt;E&gt; node)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>((node = node.parent) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(isBanlance(node)) &#123;</span><br><span class="line">            updateHeight(node); <span class="comment">// 更新高度</span></span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            rebalance(node); <span class="comment">// 恢复平衡</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="添加节点"><a href="#添加节点" class="headerlink" title="添加节点"></a>添加节点</h3><ul>
<li>可能会导致所有祖先节点都失衡</li>
<li>只要让高度最低的失衡节点恢复平衡，整棵树就恢复平衡【仅需O(1)次调整】</li>
</ul>
<h3 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h3><ul>
<li>只可能会导致父节点或祖先节点失衡，让父节点恢复平衡后，可能会导致更高层的祖先节点失衡【最多需要O(logn)次调整】</li>
</ul>
<h3 id="平均时间复杂度"><a href="#平均时间复杂度" class="headerlink" title="平均时间复杂度"></a>平均时间复杂度</h3><ul>
<li><p>搜索：O(logn)</p>
</li>
<li><p>添加：O(logn)，仅需O(1)次的旋转操作</p>
</li>
<li><p>删除：O(logn)，最多需要 O(logn)次的旋转操作</p>
</li>
</ul>
</article><div id="paginator"></div></main><footer><div class="icon-wrapper in-left"><button class="icon-button" aria-label="change theme"><span class="icon"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" height="100%" width="100%"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z"></path></svg></span></button></div><div class="icon-wrapper in-right"><button class="icon-button" aria-label="change theme"><span class="icon"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" height="100%" width="100%"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 15l7-7 7 7"></path></svg></span></button></div><p class="copyright-text"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noreferrer">CC BY-NC-SA 4.0</a><span>·</span><a href="https://github.com/ttttonyhe/ouorz-mono" target="_blank" rel="noreferrer">Open Source Software (OSS)</a></p></footer><script src="/js/ouo.js"></script></div></body></html>