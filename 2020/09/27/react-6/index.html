<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><title>前端学习之React中的路由 [ Mahoo12138 ]</title><link rel="stylesheet" href="/css/index.css"><meta name="post"><link rel="stylesheet" href="/css/layouts/post.css"><meta name="generator" content="Hexo 7.3.0"></head><body><div id="hexo-container"><header></header><main id="content"><article id="post"><h1>前端学习之React中的路由</h1><h2 id="React-路由介绍"><a href="#React-路由介绍" class="headerlink" title="React 路由介绍"></a>React 路由介绍</h2><p>前端路由就是一套映射规则，是URL路径与组件的对应关系，实现从一个页面到另一个页面的跳转；</p>
<h3 id="Router-组件"><a href="#Router-组件" class="headerlink" title="Router 组件"></a>Router 组件</h3><p>使用 React Router API 中的两种类型的路由：</p>
<ul>
<li>BrowserRouter</li>
<li>HashRouter</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// &lt;BrowserRouter&gt;</span><br><span class="line">http://example.com/about</span><br><span class="line">// &lt;HashRouter&gt;</span><br><span class="line">http://example.com/#/about</span><br></pre></td></tr></table></figure>

<p><code>&lt;BrowserRouter&gt;</code> 在两者中会更受欢迎些，因为它使用的是 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/History_API">HTML5 History API</a> 来保持应用的页面与 URL 同步，而 <code>&lt;HashRouter&gt;</code> 则使用的是 URL 的哈希部分（<code>window.location.hash</code>，其原理就是监听哈希值的改变进行对应的渲染）。如果你的代码运行在不支持 <code>History API</code> 的传统浏览器上，你应该使用 <code>&lt;HashRouter&gt;</code> ，否则 <code>&lt;BrowserRouter&gt;</code> 对于大多数情况来说是更好的选择。</p>
<blockquote>
<p><code>history</code> 这个库可以让你在 JavaScript 运行的任何地方都能轻松地管理回话历史，<code>history</code> 对象抽象化了各个环境中的差异，并提供了最简单易用的的 API 来给你管理历史堆栈、导航，并保持会话之间的持久化状态。 </p>
</blockquote>
<h4 id="BrowserRouter："><a href="#BrowserRouter：" class="headerlink" title="BrowserRouter："></a>BrowserRouter：</h4><p><code>BrowserRouter</code> 要求服务端对发送的不同的 URL 都要返回对应的 HTML，比如说现在有如下两个 URL 发送 GET 请求到服务端：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http://example.com/home </span><br><span class="line">http://example.com/about</span><br></pre></td></tr></table></figure>

<p>那么这个时候服务端拿到的是完整的 URL，这时候服务端就必须分别对 <code>/home</code> 和 <code>/about</code> 做处理并返回相应的 HTML 来给到客户端渲染。这个带来的影响就是，如果你切换到某个服务端没有做相应处理的页面路由，比如：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://example.com/article</span><br></pre></td></tr></table></figure>

<p>如果你在 SPA 中写了这部分路由要渲染的页面，在页面无刷新情况下跳转是没啥问题的。但是如果你直接在此路由下进行页面的<strong>刷新</strong>，就会得到一个 404。 </p>
<h4 id="HashRouter"><a href="#HashRouter" class="headerlink" title="HashRouter"></a>HashRouter</h4><p><code>HashRouter</code> 在 URL 中使用哈希符号（<code>#</code>）来使服务端忽略 <code>#</code> 后面所有的 URL 内容，比如你在浏览器地址栏中直接输入以下 URL：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http://example.com/#/home </span><br><span class="line">http://example.com/#/about</span><br></pre></td></tr></table></figure>

<p>服务端拿到的只会是 <code>http://example.com/</code> ，这样服务端只需要对这个路由做处理并返回 HTML，然后后面的路由 <code>/home</code> 或 <code>/about</code> 将全部交给客户端（也就是我们的 SPA 应用）来处理并渲染对应的页面。所以你在任意的路由进行页面的<strong>刷新</strong>都不会是 404。</p>
<h3 id="Link-和-Route-组件"><a href="#Link-和-Route-组件" class="headerlink" title="Link 和 Route 组件"></a>Link 和 Route 组件</h3><p>如果当前的位置 pathname 与路由的路径 path 匹配，就会渲染对应的 UI。理想情况下，<code>&lt;Route&gt;</code> 组件应该有一个名为 <code>path</code> 的属性，如果路径名称与当前位置匹配，它就会被渲染。</p>
<p><code>&lt;Link&gt;</code> 组件被用来在页面之间进行导航，它其实就是 HTML 中的 <code>&lt;a&gt;</code> 标签的上层封装，不过在其源码中使用 <code>event.preventDefault</code> <strong>禁止了其默认行为</strong>，然后使用 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/History_API">history API</a> 自己实现了跳转。我们都知道，如果使用 <code>&lt;a&gt;</code> 标签去进行导航的话，整个页面都会被刷新，这是我们不希望看到的，当然，跳转到首页这种行为是推荐使用 <code>&lt;a&gt;</code> 标签的；</p>
<h3 id="Switch-组件"><a href="#Switch-组件" class="headerlink" title="Switch 组件"></a>Switch 组件</h3><p>当多个 <code>&lt;Route&gt;</code> 被一起使用时，所有匹配到的路由都会被渲染，因为路由默认是模糊匹配的；使用 <code>&lt;Switch&gt;</code> ，只有第一个与当前 URL 匹配到的子 <code>&lt;Route&gt;</code> 才会被渲染；</p>
<h2 id="路由基本使用"><a href="#路由基本使用" class="headerlink" title="路由基本使用"></a>路由基本使用</h2><ul>
<li><p>安装：<code>npm install react-router-dom</code></p>
</li>
<li><p>导入路由的三个核心组件：BrowserRouter，Route，Link：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;<span class="title class_">BrowserRouter</span> <span class="keyword">as</span> <span class="title class_">Router</span>, <span class="title class_">Route</span>, <span class="title class_">Link</span>&#125; <span class="keyword">from</span> <span class="string">&#x27;react-router-dom&#x27;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 Router 组件包裹整个应用；</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">App</span> = (<span class="params"></span>) =&gt; (</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">Router</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>路由基本使用<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">Router</span>&gt;</span></span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 Link 组件作为导航菜单（路由入口），最终会被渲染为 a 元素： </p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">Link</span> to=<span class="string">&quot;/first&quot;</span>&gt;页面 <span class="number">1</span>&lt;/<span class="title class_">Link</span>&gt;</span><br></pre></td></tr></table></figure>

<p><code>NavLink</code>是类似于<code>Link</code>，可以设置属性<code>activeStyle</code>或是<code>activeClassName</code>设置样式；</p>
</li>
<li><p>使用 Route 组件配置路由规则和要展示的内容（路由出口）</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">Route</span> path=<span class="string">&quot;/first&quot;</span> component=&#123;<span class="title class_">First</span>&#125;&gt;&lt;<span class="regexp">/Route&gt;		/</span>/ <span class="title class_">First</span> 组件</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 Switch  对路由做排他处理，将<code>Route</code>包裹在<code>Switch</code>内部，只要路由匹配到了一个其他的都不在匹配；通常情况下，还需要一个默认匹配的路由：</p>
<blockquote>
<p>最新的Router V6 中，<code>&lt;Switch&gt;</code>重命名为<code>&lt;Routes&gt;</code>，路由中的属性<code>component</code>重命名为<code>element</code>；</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;Route</span><br><span class="line">    path=&quot;*&quot;</span><br><span class="line">    element=&#123;</span><br><span class="line">        &lt;main&gt;&lt;p&gt;There&#x27;s nothing here!&lt;/p&gt;&lt;/main&gt;</span><br><span class="line">    &#125;</span><br><span class="line">    /&gt;</span><br><span class="line">&lt;/Route&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h2><p>我们以一个常见的场景演示一下动态路由，即商城的商品详情页面：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">Router</span>&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>动态路由使用<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">List</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&#x27;/detail/:id&#x27;</span> <span class="attr">component</span>=<span class="string">&#123;Detail&#125;</span>&gt;</span><span class="tag">&lt;/<span class="name">Route</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/<span class="title class_">Router</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">List</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span>&#123;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>(</span><br><span class="line">            <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">h2</span>&gt;</span>列表页<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">&#x27;/detail/1&#x27;</span>&gt;</span>一号商品页面<span class="tag">&lt;/<span class="name">Link</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">&#x27;/detail/2&#x27;</span>&gt;</span>二号商品页面<span class="tag">&lt;/<span class="name">Link</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">&#x27;/detail/3&#x27;</span>&gt;</span>三号商品页面<span class="tag">&lt;/<span class="name">Link</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Detail</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">    <span class="title function_">componentDidMount</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">match</span>.<span class="property">params</span>.<span class="property">id</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">h2</span>&gt;</span>商品详情页面<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">h4</span>&gt;</span>&#123;&quot;请求获取&quot; + this.props.match.params.id + &quot;号页面数据&quot;&#125;<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="权限路由"><a href="#权限路由" class="headerlink" title="权限路由"></a>权限路由</h2><h3 id="Redirect-组件"><a href="#Redirect-组件" class="headerlink" title="Redirect 组件"></a><del>Redirect 组件</del></h3><blockquote>
<p>最新的React-router-dom v6升级改动中，将<code>Redirect</code>移除了，替代方案是引入<code>Navigate</code>标签；</p>
</blockquote>
<p>与服务端的重定向类似，React Router 的 <a target="_blank" rel="noopener" href="https://reactrouter.com/web/api/Redirect">Redirect component</a> 将会用一个新的位置替换历史栈中的当前位置，新的位置是由 <code>to</code> 属性来指向的。那么接下来我就会向大家介绍如何使用 <code>&lt;Redirect&gt;</code> ：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">Redirect</span> to=&#123;&#123; <span class="attr">pathname</span>: <span class="string">&#x27;/login&#x27;</span>, <span class="attr">state</span>: &#123; <span class="attr">from</span>: location &#125;&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>如果有人试图在未登录状态下访问 <code>/admin</code> 路由，他就会被重定向到 <code>/login</code> 路由，关于当前位置的信息是由 <code>state</code> 属性进行传递的，这样做是为了在用户登录成功之后，用户又可以被重定向到他试图访问的路由页面。</p>
<h3 id="自定义路由"><a href="#自定义路由" class="headerlink" title="自定义路由"></a>自定义路由</h3><p>如果我们需要决定一个路由是否应该被渲染，那么编写一个自定义路由是个好办法：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">PrivateRoute</span> = (<span class="params">&#123; component: Component, ...rest &#125;</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> location = <span class="title function_">useLocation</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">Route</span> &#123;<span class="attr">...rest</span>&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;isLogin === true ? (</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Component</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      ) : (</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Redirect</span> <span class="attr">to</span>=<span class="string">&#123;&#123;</span> <span class="attr">pathname:</span> &quot;/<span class="attr">login</span>&quot;, <span class="attr">state:</span> &#123; <span class="attr">from:</span> <span class="attr">location</span> &#125; &#125;&#125; /&gt;</span></span></span><br><span class="line"><span class="language-xml">      )&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">Route</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">PrivateRoute</span>;</span><br></pre></td></tr></table></figure>

<h2 id="编程式导航"><a href="#编程式导航" class="headerlink" title="编程式导航"></a>编程式导航</h2><h2 id="默认路由"><a href="#默认路由" class="headerlink" title="默认路由"></a>默认路由</h2><h2 id="匹配模式"><a href="#匹配模式" class="headerlink" title="匹配模式"></a>匹配模式</h2><h2 id="统一管理路由"><a href="#统一管理路由" class="headerlink" title="统一管理路由"></a>统一管理路由</h2><p>React Router 也能像 Vue Router 一样在单独的文件中管理路由，需要安装包：<code>react-router-config</code> ;</p>
<p>[^参考]: <a target="_blank" rel="noopener" href="https://juejin.cn/post/6966242922278682632">React Router 5 完整指南 - 掘金 (juejin.cn)</a></p>
</article><div id="paginator"></div></main><footer><div class="icon-wrapper in-left"><button class="icon-button" aria-label="change theme"><span class="icon"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" height="100%" width="100%"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z"></path></svg></span></button></div><div class="icon-wrapper in-right"><button class="icon-button" aria-label="change theme"><span class="icon"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" height="100%" width="100%"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 15l7-7 7 7"></path></svg></span></button></div><p class="copyright-text"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noreferrer">CC BY-NC-SA 4.0</a><span>·</span><a href="https://github.com/ttttonyhe/ouorz-mono" target="_blank" rel="noreferrer">Open Source Software (OSS)</a></p></footer><script src="/js/ouo.js"></script></div></body></html>