<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><title>TypeScript学习-04-项目接口开发 [ Mahoo12138 ]</title><link rel="stylesheet" href="/css/index.css"><meta name="post"><link rel="stylesheet" href="/css/layouts/post.css"><meta name="generator" content="Hexo 7.3.0"></head><body><div id="hexo-container"><header></header><main id="content"><article id="post"><h1>TypeScript学习-04-项目接口开发</h1><h2 id="装饰器实现路由"><a href="#装饰器实现路由" class="headerlink" title="装饰器实现路由"></a>装饰器实现路由</h2><p>在<code>src/</code>主目录下，新建目录<code>controller</code>，并创建两个文件<code>LoginController.ts</code>和<code>decorators.ts</code>；</p>
<p>在<code>decorators.ts</code>文件中，在方法的装饰器上定义元数据，值为路由的链接：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;reflect-metadata&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Router</span> &#125; <span class="keyword">from</span> <span class="string">&quot;express&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> router = <span class="title class_">Router</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">controller</span>(<span class="params"><span class="attr">target</span>: <span class="built_in">any</span></span>) &#123;</span><br><span class="line">  <span class="comment">// 类构造器拿到的是构造函数</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> target.<span class="property"><span class="keyword">prototype</span></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> path = <span class="title class_">Reflect</span>.<span class="title function_">getMetadata</span>(<span class="string">&quot;path&quot;</span>, target.<span class="property"><span class="keyword">prototype</span></span>, key);</span><br><span class="line">    <span class="keyword">const</span> hander = target.<span class="property"><span class="keyword">prototype</span></span>[key];</span><br><span class="line">    <span class="keyword">if</span>(path)&#123;</span><br><span class="line">      router.<span class="title function_">use</span>(path,hander)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">get</span>(<span class="params"><span class="attr">path</span>: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">  <span class="comment">// 方法装饰器拿到的是原型对象</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"><span class="attr">target</span>: <span class="built_in">any</span>, <span class="attr">key</span>: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="title class_">Reflect</span>.<span class="title function_">defineMetadata</span>(<span class="string">&quot;path&quot;</span>, path, target, key);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>LoginController.ts</code>中，设置构造器，也可以将<code>controller</code>构造器设为工厂构造器，依次可配置每个请求地址的前缀：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@controller</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LoginController</span> &#123;</span><br><span class="line">    <span class="meta">@get</span>(<span class="string">&quot;/&quot;</span>)</span><br><span class="line">    <span class="title function_">home</span>(<span class="params"><span class="attr">req</span>: <span class="title class_">Request</span>, <span class="attr">res</span>: <span class="title class_">Response</span></span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> isLogin = req.<span class="property">session</span> ? req.<span class="property">session</span>.<span class="property">login</span> : <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (isLogin) &#123;</span><br><span class="line">            res.<span class="title function_">send</span>(<span class="string">&#x27;...&#x27;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            res.<span class="title function_">send</span>(<span class="string">&#x27;...&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="多种请求方法"><a href="#多种请求方法" class="headerlink" title="多种请求方法"></a>多种请求方法</h3><p>除了基本的<code>get</code>方法，还有<code>post</code>装饰器，解决方法很简单，可以在定义元数据时，多一个对方法的定义：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">post</span>(<span class="params"><span class="attr">path</span>: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"><span class="attr">target</span>: <span class="built_in">any</span>, <span class="attr">key</span>: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="title class_">Reflect</span>.<span class="title function_">defineMetadata</span>(<span class="string">&#x27;path&#x27;</span>, path, target, key);</span><br><span class="line">    <span class="title class_">Reflect</span>.<span class="title function_">defineMetadata</span>(<span class="string">&#x27;method&#x27;</span>, <span class="string">&#x27;post&#x27;</span>, target, key);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而在<code>controller</code>装饰器中，只需要对方法类型做一下判断即可：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Method</span> &#123;</span><br><span class="line">  get = <span class="string">&quot;get&quot;</span>,</span><br><span class="line">  post = <span class="string">&quot;post&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">controller</span>(<span class="params"><span class="attr">target</span>: <span class="built_in">any</span></span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">const</span> <span class="attr">method</span>:<span class="title class_">Method</span> = <span class="title class_">Reflect</span>.<span class="title function_">getMetadata</span>(<span class="string">&quot;method&quot;</span>, target.<span class="property"><span class="keyword">prototype</span></span>, key);</span><br><span class="line">    <span class="keyword">if</span> (path &amp;&amp; method) &#123;</span><br><span class="line">        router[method](path, hander);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意上述代码中的<code>Method</code>类型，对请求方法做一个枚举，因为<code>getMetadata</code>获取的数据是<code>any</code>类型，而在<code>router[method]</code>表达式中需要字符串类型，这是为了更好的类型推断； </p>
<p>如果在此基础上，还需要引入<code>delete</code>，<code>put</code>等方法的装饰器，那就还需要再复制粘贴代码进行改动，这未免显得太不够优雅，我们可以定义一个函数进行统一创建：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">getRequestDecorator</span> = (<span class="params"><span class="attr">method</span>: <span class="title class_">Method</span></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"><span class="attr">path</span>: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"><span class="attr">target</span>: <span class="built_in">any</span>, <span class="attr">key</span>: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">      <span class="title class_">Reflect</span>.<span class="title function_">defineMetadata</span>(<span class="string">&quot;path&quot;</span>, path, target, key);</span><br><span class="line">      <span class="title class_">Reflect</span>.<span class="title function_">defineMetadata</span>(<span class="string">&quot;method&quot;</span>, method, target, key);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> get = <span class="title function_">getRequestDecorator</span>(<span class="title class_">Method</span>.<span class="property">get</span>);</span><br></pre></td></tr></table></figure>

<h2 id="装饰器添加中间件"><a href="#装饰器添加中间件" class="headerlink" title="装饰器添加中间件"></a>装饰器添加中间件</h2><p>完成上述的操作后，原先的爬虫程序就只剩下爬取数据和展示数据的接口没有迁移了，我们可以注意到，这两个接口其实与登录并无关系，那么可以新建<code>CrowllerController.ts</code>；除此之外，这两个接口与之前的接口不通之处在于，它们使用了自定义的中间件来检验是否已登录；这里我们可以使用<code>use</code>装饰器对中间件进行处理：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">use</span>(<span class="params"><span class="attr">middleware</span>: <span class="title class_">RequestHandler</span></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"><span class="attr">target</span>: <span class="built_in">any</span>, <span class="attr">key</span>: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">        <span class="title class_">Reflect</span>.<span class="title function_">defineMetadata</span>(<span class="string">&quot;middleware&quot;</span>, middleware, target, key);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样的，在方法中定义了装饰器后，我们需要去类装饰器中进行处理：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">controller</span>(<span class="params"><span class="attr">target</span>: <span class="built_in">any</span></span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">const</span> middleware = <span class="title class_">Reflect</span>.<span class="title function_">getMetadata</span>(<span class="string">&quot;middleware&quot;</span>, target.<span class="property"><span class="keyword">prototype</span></span>, key);</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (middleware) &#123;</span><br><span class="line">        router[method](path, middleware, hander);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        router[method](path, hander);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="添加多个中间件"><a href="#添加多个中间件" class="headerlink" title="添加多个中间件"></a>添加多个中间件</h3><p>需要设置多个中间件时，只需要将中间件作为数组进行定义即可：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">use</span>(<span class="params"><span class="attr">middleware</span>: <span class="title class_">RequestHandler</span></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"><span class="attr">target</span>: <span class="built_in">any</span>, <span class="attr">key</span>: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="attr">middlewares</span>:<span class="title class_">RequestHandler</span>[] = <span class="title class_">Reflect</span>.<span class="title function_">getMetadata</span>(<span class="string">&quot;middlewares&quot;</span>,target, key) || [];</span><br><span class="line">    middlewares.<span class="title function_">push</span>(middleware);</span><br><span class="line">    <span class="title class_">Reflect</span>.<span class="title function_">defineMetadata</span>(<span class="string">&quot;middlewares&quot;</span>, middlewares, target, key);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>controller</code>装饰器中，只需要对数组进行展开即可：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">controller</span>(<span class="params"><span class="attr">target</span>: <span class="built_in">any</span></span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">const</span> <span class="attr">middlewares</span>:<span class="title class_">RequestHandler</span>[] = <span class="title class_">Reflect</span>.<span class="title function_">getMetadata</span>(<span class="string">&quot;middlewares&quot;</span>, target.<span class="property"><span class="keyword">prototype</span></span>, key);</span><br><span class="line">    <span class="keyword">if</span> (middlewares &amp;&amp; middlewares.<span class="property">length</span>) &#123;</span><br><span class="line">        router[method](path, ...middlewares, hander);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        router[method](path, hander);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="代码结构优化"><a href="#代码结构优化" class="headerlink" title="代码结构优化"></a>代码结构优化</h2><p>经过上述的编码，我们可以发现很多问题，例如路由的创建其实是在<code>decorator.ts</code>文件中创建的，这显然与它的用途杂糅了，我们可以在根目录创建一个<code>router.ts</code>，并处理好引用包即可：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Router</span> &#125; <span class="keyword">from</span> <span class="string">&quot;express&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="title class_">Router</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router;</span><br></pre></td></tr></table></figure>

<p>其次则可以将<code>decorator.ts</code>内的内容根据不同作用进行划分，新建<code>decorator</code>文件夹及<code>controller.ts</code> 、<code>request.ts</code>、 <code>use.ts</code>三个文件分别对应三种装饰器，并作代码划分；</p>
<p>继而在<code>decorator</code>文件夹内，新建<code>index.ts</code>作为引用入口文件：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;reflect-metadata&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">&quot;./controller&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">&quot;./request&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">&quot;./use&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>这样处理之后，目录结构会清晰很多，且导入包时也更统一，如在<code>LoginController</code>中导入时，直接导入目录<code>decorator</code>即可，会自动导入下面的<code>index.ts</code>文件：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; controller, get, post &#125; <span class="keyword">from</span> <span class="string">&quot;../decorator&quot;</span>;</span><br></pre></td></tr></table></figure>

</article><div id="paginator"></div></main><footer><div class="icon-wrapper in-left"><button class="icon-button" aria-label="change theme"><span class="icon"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" height="100%" width="100%"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z"></path></svg></span></button></div><div class="icon-wrapper in-right"><button class="icon-button" aria-label="change theme"><span class="icon"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" height="100%" width="100%"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 15l7-7 7 7"></path></svg></span></button></div><p class="copyright-text"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noreferrer">CC BY-NC-SA 4.0</a><span>·</span><a href="https://github.com/ttttonyhe/ouorz-mono" target="_blank" rel="noreferrer">Open Source Software (OSS)</a></p></footer><script src="/js/ouo.js"></script></div></body></html>